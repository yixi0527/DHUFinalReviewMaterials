# BCD码

## 8421码

二进制表示[0,15]

超过表示范围就+6（0110）

## 余3码

8421码+$(0011)_2$

## 2421码

四位的权值为2421

0~4 首位为0

5~9 首位为1

避免歧义

# 数的机器码表示

## 原码

正数：最前面加一个符号位

负数：最前面加一个符号位

## 反码

正数：不变

负数：与原码数值位相反

## 补码

正数：不变

负数：原负数加上模。

- 定点小数x0.x1x2…xn ，以2为模

- 定点整数x0x1x2…xn ，以2n+1为模

- 负数求补码的简单方法：

    负数原码从右到左找到第一个1，这个1**左边，不包括这个1**的所有**数值位**按位取反。


## 移码

只能表示整数

$[X]_{移码} = 2^n + X \\ -2^n \leq X < 2^n$​

在补码的基础上将符号位取反就得到移码。

最高位为符号位

> 例：
>
> [105]移码＝10000000＋01101001＝11101001
>
> [-105]移码＝10000000－01101001＝00010111

## 特殊/易错

1. 如果码长为8位：-128只有补码1000 0000，没有原码和反码。

    ​			    相当于-128+128=0，符号位1，结果1000 0000。

    同理，码长位16位，-32768只有补码1000 0000 0000 0000.

2. 0:

    ​	原码：+0：00000000 -0：10000000

    ​	反码：+0：00000000 -0：11111111

    ​	补码：+0：00000000 -0：00000000

# 数据格式

- 定点格式：容许的数值范围有限，但要求的处理硬件比较简单
- 浮点格式：容许的数值范围很大，但要求的处理硬件比较复杂

## 定点表示法

约定机器中所有数据的小数点位置是固定不变的。通常将数据表示成纯小数或纯整数。

- 定点纯小数，小数点位于符号位之后，不需专门存放位置。

    $-1<X<+1$

    | 机器码（原码）                 | 表示的数      | 说明                                                    |
    | ------------------------------ | ------------- | ------------------------------------------------------- |
    | x = 0.00...0<br />x = 1.00...0 | 0             | 正负0                                                   |
    | x = 0.11...1                   | $1-2^{-n}$    | 能表示的最大的正数<br />相当于1.00...0(2) - 0.00...1(2) |
    | x = 0.00...01                  | $2^{-n}$      | 最接近0的正数                                           |
    | x = 1.00...01                  | $-2^{-n}$     | 最接近0的负数                                           |
    | x = 1.11...1                   | $-(1-2^{-n})$ | 最小负数                                                |

    定点小数的补码：最小的数为1.000...00=-1

    真值0只有一种补码：0.000...00=0

- 定点纯整数，小数点位于最后一位之后，不需专门存放位置。

​	$-(2^n-1)\leq X \leq +(2^n-1)$

## 浮点表示法

$N = R^E.M$

R：基数，取固定值，一般为2，隐含表示

E：指数，用移码

M：尾数，用原码

**IEEE754标准**规定了浮点数的表示格式，运算规则等。

![image-20240518121929084](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518121929084.png)

数符S：0正1负

阶码E：含阶符的阶码，采用移码方式来表示正负指数。反映浮点数的表示范围和小数点的实际位置。

尾数M：尾数最高有效位为1，小数点放在尾数域最前面。反映浮点数的精度。

- 真值为0的机器数：阶码E=0，尾数M=0。正0：S=0,负0：S=1.
- 无穷大的机器数：阶码E全1，尾数M=0。正无穷：S=0,负无穷：S=1.
- 非规格化小数：阶码E全0，尾数M不全0.
- NaN：阶码E全1，尾数M != 0. 不是一个数，通知异常情况。

|      | E=1    | E=0          |
| ---- | ------ | ------------ |
| M!=0 | NaN    | 非规格化小数 |
| M=0  | 无穷大 | 0            |

### 32位单精度浮点数规格化表示

$$
x = & (-1)^s\times (1.M) \times 2^e \\
e = & E - 127
$$

- E = 0000 0001 ~ 1111 1110 (1~254)

- e = -126 ~ +127

- 最小绝对值

    e=-126,M=0

​	1.M = 1

​	$1.0 \times 2^{-126} \approx 1.18 \times 10^{-38}$

- 最大绝对值

    e=127,M=11...1(23个1)

​	1.M = 1.11...1 = $2 - 2^{-23}$

​	$(2-2^{-23}) \times 2^{127} \approx 3.40 \times 10^{38}$

### 64位单精度浮点数规格化表示

$$
x = & (-1)^s\times (1.M) \times 2^e \\
e = & E - 1023
$$

- E = 1~2046

- e = -1022~+1023

- 最小绝对值

    e=-1022,M=0

​	1.M = 1

​	$1.0 \times 2^{-1022} \approx 2.23 \times 10^{-308}$

- 最大绝对值

    e=1023,M=11...1(52个1)

​	1.M = 1.11...1 = $2 - 2^{-52}$

​	$(2-2^{-52}) \times 2^{1023} \approx 1.79 \times 10^{308}$

> 例1：**浮点机器数** (41360000)16，求真值
>
> -   十六进制转二进制
>
>     0 100 0001 0011 0110 0000 0000 0000 0000
>
>     S = 0
>
>     E = 10000010
>
>     M = 011 0110 0000 0000 0000 0000
>
> -   e = E - 127 = 1000 0010 - 0111 1111 = 0000 0011 = 3(10)
>
> -   1.M = 1.011011
>
> -   X = + 1.011011 $\times$ $2^3$
>
>       = +1011.011
>
>     = 11.375
>
> 例2：真值20.59375，求32位单精度浮点数
>
> -   十进制转二进制
>
>     10100.10011
>
> -   变成1.M
>
>     10100.10011 = 1.010010011 $\times 2^4$
>
> -   e = 4
>
> -   E = e+127 = 131(10) = 10000011
>
> -   S = 0
>
> -   M = 010010011
>
> -   S E M = 
>
>     0 100 0001 1010 0100 1100 0000 0000 0000

### 尾数规格化

   在规格化浮点运算中，若运算结果不是规格化数，必须进行规格化处理。

- 原码表示中：

    满足$\frac{1}{2} \leq |M| < 1$​的数为规格化数。即**尾数最高位必须为1**。

    0.1xx...x

    1.1xx...x

- 补码表示中：

    满足$-1 \leq M < - \frac{1}{2}$ 或  $\frac{1}{2} \leq M < 1$。即**符号位和有效位最高位必须不同**。​

    00.1xx...x

    11.0xx...x

- 把尾数变成规范化的格式——移位。同时调整阶数从而保证数值本身不变，左规阶数-1，右规阶数+1。

    双符号位补码表示发生假溢出，第一个符号位指示了真的符号。因此右规。否则左规。

    原码：

    > 例：
    >
    > | 不规范数 | 规范数 | 方法 | 补0/1 | 阶码变化 |
    > | -------- | ------ | ---- | ----- | -------- |
    > | 0.0101   | 0.1010 | 左规 | 低位0 | -1       |
    > | 1.0101   | 1.1010 | 左规 | 低位0 | -1       |

    补码：

    > 例：
    >
    > | 不规范数 | 规范数   | 方法 | 补0/1 | 阶码变化 |
    > | -------- | -------- | ---- | ----- | -------- |
    > | 1.1101   | 1.0100   | 左规 | 低位0 | -2       |
    > | 11.1001  | 11.0010  | 左规 | 低位0 | -1       |
    > | 01.0101  | 00.10101 | 右规 | 高位0 | +1       |
    > | 10.0101  | 11.00101 | 右规 | 高位1 | +1       |

**总之就是把不规范的变成规范的样子，右移就+阶码，左移就-阶码**

## 溢出与溢出检测

- 上溢（正溢出）：两个正数相加的结果超出机器所能表示的最大正数。
- 下溢（负溢出）：两个负数相加的结果小于机器所能表示的最小负数。
-  检测方法

#### 双符号位法

- 变形补码：采用两个符号位的补码。

​	00 正确，正数

​	01 上溢

​	10 下溢

​	11 正确，负数

#### 单符号位法

与上面一样，只是最高位是符号位产生的进位，第二位是最高有效位产生。

# 基本的二进制加法/减法器

- 半加器：两数相加，不考虑低位进位
- 全加器：完成两个二进制数相加，考虑低位进位。（完成三个一位数相加的功能）

## 一位全加器FA

实现两个二进制数字$A_i,B_i$和一个进位输入$C_i$（来自低位的进位）相加,产生一个本位和输出$S_i$,以及一个进位输出$C_{i+1}$​。

- 一位全加器真值表

| $A_i$ | $B_i$ | $C_i$ | $S_i$ | $C_{i+1}$ |
| ----- | ----- | ----- | ----- | --------- |
| 0     | 0     | 0     | 0     | 0         |
| 0     | 0     | 1     | 1     | 0         |
| 0     | 1     | 0     | 1     | 0         |
| 0     | 1     | 1     | 0     | 1         |
| 1     | 0     | 0     | 1     | 0         |
| 1     | 0     | 1     | 0     | 1         |
| 1     | 1     | 0     | 0     | 1         |
| 1     | 1     | 1     | 1     | 1         |

- 一位全加器逻辑表达式

$$
S_i & = A_i \oplus B_i \oplus C_i \\ C_{i+1} & = A_iB_i + A_iC_i + B_iC_i \\ & = A_iB_i + (A_i \oplus B_i)C_i
$$

​	*逻辑表达式可以变形，每个逻辑表达式都可以对应一个电路，故电路形式不是唯一的*

- 一位全加器内部结构图

![image-20240518134844385](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518134844385.png)

- $C_{i+1}相对于C_i延时为2T$
- $C_{i+1}相对于A_i延时为5T$
- $S_{i}相对于A_i延时为6T$

---

## 串行加法器（行波进位加法器）

从低位开始，每步只完成一位运算的加法。

- 只需要一个全加器和一个进位触发器。

- 计算两个n位数之和，需要n+1步（1位符号位）或n+2步（2位符号位）运算。

- 高位运算只有等低位运算完成后才能进行，速度较慢。

    ​	![行波进位加法器](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/0c30d26c155f766b28dc0abe5091b51.jpg)

    - 考虑溢出时，延迟$t = n \times 2T + 9T$
    - 不考虑溢出时，延迟$t = (n - 1) \times 2T + 9T$​
    - M控制加减，单符号溢出检测

    > 引用自[全加器以及行波进位加/减法器时延的计算 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/590151247)@[胡平](https://www.zhihu.com/people/hu-ping-70)
    >
    > - **输入减数和被减数**。开始进行计算（我们假定：数据的输入是瞬时的，时延是0T）。
    > - **最低位的全加器的进位时延**。最低位的全加器的一个输入端需要等待取反异或门的输出，异或门的时延是3T；3T 之后，被减数到达全加器的输入端，从加器的输入端经过8T 的时延（3T的取反+5T的全加器进位）后，进位输出；9T （3T的取反+6T的全加器值输出）的时延后，最低位计算值输出。
    > - **第2个到第N个全加器的进位计算**。当最低位的全加器输出进位的时候，**第2位到第N位**已经完成了被减数的取反的操作，所有全加器的两个输入端都已就绪，就差从低位的全加器中获取进位了。所以，对于剩余全加器，每个全加器输出**进位的时延不是5T，而是 2T。**
    > - **整体计算结果的溢出判断**。这个只能等所有的全加器都完成进位之后才能得出，这个是异或门判断的，时延是3T，所以N 位减法器的总计算时延为：
    > - **【最低位的取反输入异或门时延】** 3T **+ 【最低位的全加器进位时延】**5T **+ 【N-1个全加器的进位时延】**2T*(N-1) **+【溢出异或门时延】**3T

## 并行加法器

- 可在同一时刻完成n位数的运算
- 若用变形补码表示一个机器数，则符号位2位，需要n+2个加法器
- 速度比串行快很多，是用足够多的硬件设备换来的

# 乘法器

计算机中实现乘除运算通常采用以下三种方式：

- 利用乘除运算子程序

    基本思想是采用软件实现乘除运算。通常是利用计算机中的加/减运算指令、移位指令及控制类指令组成循环程序，通过在运算器中的加法器、移位器等基本部件上的反复加/减操作，得到运算结果。这种方式所需硬件简单，但实现速度较慢，主要应用在早期的小、微型机上。

- 在加法器的基础上增加左、右移位及计数器等逻辑线路构成乘除运算部件。

    在采用乘除运算部件实现乘除运算的计算机中，设置有乘除运算指令，用户只需执行乘除指令即可进行乘除运算。

- 用LSI和VLSI工艺实现专用的乘法器

    阵列乘除运算器将多个加减运算部件排成乘除运算阵列，依靠硬件资源的重复设置，同时进行多位乘除运算的乘除运算，赢得了乘除运算的高速度。

    串行的“加法和移位”方法硬件结构简单，速度太慢，已被淘汰。

## 不带符号位的阵列乘法器

这种乘法器要实现n位×n位时,需要n(n－1)个全加器和$n^2$个“与”门。 

![image-20240518143240635](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518143240635.png)

令$T_a$为与门的传输延时，$T_f$为FA的进位传输延时，$T_{fa}$为加延时（每级异或门3T，共6T）。

$T_a = T,T_f = 2T,T_{fa}=6T$

> $n \times n$延时：
> $$
> \begin{align}
> t & = T_a + (n-1)T_{fa} + (n-1)T_f + 3T \\
> & =(8n-4)T
> \end{align}
> $$

在做笔试计算题时，过程和算普通的乘法一模一样。

## 带符号的阵列乘法器

### $(n+1) \times (n+1)$位带求补器的阵列乘法器

- 原码乘，$a_n,b_n$接0，不求补。
- 补码乘，$a_n,b_n$​接符号位，求补。时间比原码乘大1倍。
- 补码乘中，输入端的求补电路是将补码转换为绝对值，输出端的求补电路是将绝对值转换为补码，符号位单独处理，增加在高位。

![image-20240518150632908](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518150632908.png)

> 例1：
>
> ![](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518150801274.png)
>
> 例2：
>
> ![image-20240518150824154](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518150824154.png)

# 除法器

## 原码除法算法原理

[原码除法 恢复余数法和不恢复余数法(加减交替法) 计组_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1DY4y177dV/?spm_id_from=333.337.search-card.all.click&vd_source=699b6cd17476125e966cc1c30dec1f32)

- 小数定点除法对被除数和除数有一定的约束，必须满足：∣被除数∣<∣除数∣

- 具有n位尾数的合法除法，需要逻辑移位n次，上商n+1次
- 若最后一次所得的余数为负，要加上y的绝对值的补码。
- 左移了几次，最后的余数要乘以2的负几次方。

### 恢复余数法

直接作减法试探方法，不管被除数(或余数)减除数是否够减，都一律先做减法。若余数为正，表示够减，该位商上“1”，余数左移（等价于被除数右移）；若余数为负，表示不够减，该位商上“0”，并要恢复原来的余数（将刚刚减掉的被除数加回去），然后余数左移。

符号位单独考虑，所以需要用到x绝对值的补码，y绝对值的补码以及-y的补码（做减法）。**做运算中一直用的是补码，减法时用-y的补码。**

若所得余数为正，表示够减，商1，余数左移1位，**减去**除数。

若所得余数为负，表示不够减，商0，余数**加上**除数，然后再左移1位，**减去**除数。

### 不恢复余数法

在恢复余数法中，若余数$r<0$，需要恢复余数，进行相加$(r+y)$，左移$(\times 2)$，减除数$(-y)$, 最终结果为$2(r+y)-y$。将这个数变换一下，得到$2r+y$​。

也就是说，**“余数加上除数，然后再左移1位，再减去除数。”**和**“余数左移1位，加上除数”**是等价的。

所以在恢复余数法中的这一步，可以简化成左移$(\times 2)$，相加$(+y)$​

若所得余数为正，表示够减，商1，余数左移1位，**减去**除数。

若所得余数为负，表示不够减，商0，余数左移1位，**加上**除数。

## 并行除法器

利用若干个加减单元组成阵列，将各步加／减、移位操作在一个节拍内完成，从而提高除法运算速度。

### 可控加法/减法（CAS）单元

![image-20240518162810608](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518162810608.png)

有四个输出端和四个输入端:

当P＝0时,CAS作加法运算

当P＝1时,CAS作减法运算
$$
S_i = A_i \oplus (B_i\oplus P)\oplus C_i \\
C_{i+1} = (A_i + C_i) · (B_i \oplus P) + A_iC_i
$$

> 逻辑运算中，异或1相当于取反，异或0相当于不变。

CAS单元的实际内部电路用一个三级组合逻辑电路(包括反向器)来实现。因此**每一个基本的CAS单元的延迟时间为3T**

使用CAS来实现不恢复余数法。

### 不恢复余数法的阵列除法器

![image-20240518163152465](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240518163152465.png)

对一个2n位除以n位的不恢复余数阵列除法器来说，单元的数量为$(n+1)^2$，除法执行时间为$3(n+1)^2T$

最上面一行的控制线P固定设置成1

# 浮点加减法

浮点数表示为$x = 2^{E_x}\cdot M_x$

$z = x \pm y = (M_x2^{E_x-E_y}\pm M_y)2^{E_y}$​

## 0操作数检查

如果有一个数为0，则不需要后续一系列操作，节省运算时间。

## 比较阶码大小，并完成对阶

对阶：把两数的小数点对齐，小阶向大阶看齐

-   求阶差：$\Delta E = E_x-E_y$
    -   0，阶码相等，不需要对阶
    -   \> 0，$E_x>E_y$，阶码向$E_x$看齐，$M_y$右移$|\Delta E|$位，$E_y+|\Delta E|$
    -   < 0，$E_x<E_y$，阶码向$E_y$看齐，$M_x$右移$|\Delta E|$位，$E_x+|\Delta E|$

-   如果向小阶对齐，尾数需要左移，易丢失高位数据
-   如果向大阶对其，尾数需要右移，丢失的是低位数据

## 尾数加减运算

若求和，直接相加；

若求差，求补再相加。

## 规格化

进行规格化处理。见“数据格式-浮点表示法-尾数规格化”

## 舍入

舍入的原则：

-   误差不超过所允许的范围，一般要求不超过最低位的1
-   误差应有正有负，不会产生积累误差

舍入的方法

-   0舍1入法：若右移时，被丢掉的数位最高位为0，则舍去；否则将1加到尾数的最低位。
-   末位恒置1法：只要右移丢失数据，都将右移后的尾数末尾置1.
-   就近舍入（四舍五入）
-   朝0舍入
-   朝$+\infty$舍入
-   朝$-\infty$舍入

## 溢出处理

由阶码判断是否溢出。

阶码<-128，下溢，发生在左规。浮点数数值趋于0，用机器0表示。

阶码>127，上溢，置溢出标志，作中断处理。是真正的溢出。

>   例：已知十进制数X = -5/256，y+59/1024。按机器补码浮点运算规则计算X-Y。结果用二进制表示。浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位。
>
>   0.   真值转二进制
>
>        $X = -101\times 2^{-8} = -0.101 \times 2^{-5} = -0.101 \times 2^{-101}$
>
>        $Y = +0.111011 \times 2^{-100}$
>
>        $X_{[补]} = 11011,11.0110 0000 0$
>
>        $Y_{[补]} = 11100,00.111011000$
>
>   1.   对阶
>
>        $\Delta E_{[补]} = E_x - E_y = {E_{x}}_{[补]} + ({-E_{y}})_{[补]} = 11011+00100 = 11111$
>
>        $\Delta E = -1 < 0$
>
>        所以阶码向Y对齐，$M_x$​右移1位，$E_x+1$。
>
>        $X:11100,11.101100000$
>
>   2.   尾数加减
>
>        $-Y_{[补]} = 11100,000101000$
>
>        $X-Y = X_{[补]}+(-Y)_{[补]} = 11.01100000 + 00.000101000 = 10.110001000$
>
>   3.   规格化
>
>        通过右规，拯救溢出
>
>        $11100,10.110001000 \rightarrow 11101,11.01100 0100$​
>
>   4.   舍入
>
>   5.   判溢出
>
>        阶码2个符号位相同，无溢出。

# 浮点乘除法

$x \times y = 2^{(E_x+E_y)}\cdot(M_x \times M_y)$

$x / y = 2^{(E_x-E_y)}\cdot(M_x / M_y)$

由于定点小数除法要求|被除数|<|除数|，因此当$|M_x| \geq |M_y|$时需要调整被除数。一般只需要将$M_x$右移一位即可。

# 浮点运算流水线

在计算机上实现时间并行性的一种非常经济的方法。

-   过程段：处理一个子任务的过程
-   线性流水线由一系列串联的过程段组成，各个过程之间设有高速的缓冲寄存器，以暂时保存上一过程子任务处理的结果
-   在一个统一的时钟控制下，数据从一个过程段流向相邻的过程段

设过程段$S_i$所需的时间为$\tau_i$，缓冲寄存器的延时为$\tau_l$，线性流水线的时钟周期定义为：

$\tau = \max\{\tau_i\} + \tau_l = \tau_m+\tau_l$

流水线处理的频率为

$f = \frac{1}{\tau}$

一个具有$k$级过程段的流水线处理$n$个任务需要的时钟周期数为

$T_k = k + (n-1)$。

其中k个时钟周期用于处理第一个任务。k个周期后，流水线被装满，剩余的$n-1$个任务只需$n-1$​个周期就可以完成了。

如果用非流水线的硬件来处理这$n$个任务，时间上只能串行进行，则所需要的时钟周期数为

$T_L = n \cdot k$

将$T_L$与$T_k$的比值定义为$k$级线性流水线的加速比

$C_k = \frac{T_L}{T_k} = \frac{n\cdot k}{k + (n-1)}$

当$n >> k$时，$C_k \rightarrow k$。也就是说，理论上k级流水线处理几乎可以提高k倍的速度。但是实际上由于存储器冲突、数据相关，这个理想的加速比不一定能达到。

![image-20240601123539491](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240601123539491.png)

**画出时空图**

![image-20240601123630447](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/image-20240601123630447.png)

# 补充知识

## 算术移位

![a628d5ceab84bd3a58ff32bd7ba3b33](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/a628d5ceab84bd3a58ff32bd7ba3b33.jpg)

考虑其他码值的负数和原码正数的转换即可想通。

## 门电路

各种逻辑门。与或逻辑运算之间存在分配律、结合律。

![逻辑门的种类与电路图介绍](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/R-C.7d4a14d582c20aa25fc6331d2d43f360rik=IbZrSux5I9sBVA&riu=http%253a%252f%252fwww.ejiguan.cn%252fuploadfile%252f2022%252f0214%252f20220214074310193.jpeg)

T被定义为相应于单级逻辑电路的单位门（“与”门或“或”门)延迟。异或延迟3T。

## 求补电路

输入E代表是否要求补。0代表不求补。1时求补，接符号位。

![img](./2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.assets/afcd539b8c4152a65393aad81f08f85a.png)

用这种对2求补器来转换一个(n＋1)位带符号的数,所需的总时间延迟为：

$t_{TC} = n \times 2T + 5T = (2n+5)T$