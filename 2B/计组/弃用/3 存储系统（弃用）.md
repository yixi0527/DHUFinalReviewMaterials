# 存储器的基本概念

## 存储器的层次结构

![b7bb0940a09fdcf0002c90ef7b24e08](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/b7bb0940a09fdcf0002c90ef7b24e08.jpg)

## 存储器的分类

-   按层次

    -   高速缓存

    -   主存

    -   辅存

-   按存储介质

    -   半导体存储器

    -   磁表面存储器

    -   光存储器

-   按存取方式

    -   随机存取存储器RAM：与存储的物理位置无关，取哪里的数据都是相同的时间

    -   顺序存取存储器SAM：与存储的物理位置有关

    -   直接存取存储器DAM：既有随机存取特性，又有顺序存取特性

        后两者为串行访问存储器

    -   相联存储器CAM：快表

-   存储内容可变性

    -   读写存储器
    -   只读存储器ROM：BIOS在ROM中

-   信息易失性：

    -   断电后，存储信息是否消失
        -   易失性存储器：主存、cache
        -   非易失性存储器：磁盘、光盘
    -   信息读出后，原存储信息是否被破坏
        -   破坏性读出：DRAM
        -   非破坏性读出：SRAM

## 存储器的性能指标

-   存储容量

    存储字数*字长

---

-   存取时间

​	启动到完成一次存储器操作所经历的时间

-   存储周期

    连续启动两次操作所需间隔的最小时间

    存储周期=存取时间+恢复时间

-   存储速度/主存带宽/存储器带宽

    数据传输率 = 数据的宽度/存储周期

    位/秒

    字节/秒

---

-   单位成本

​	每位价格 = 总成本/总容量

## 局部性原理

处理器访问存储器时，所访问的存储单元在一段时间内都趋向于一个较小的连续区域中。

# SRAM和DRAM

## 基本概念

主存根据信息存储的机理不同可以分为两类

-   SRAM
    -   以（双稳态）触发器（锁存器）为基本存储单元
    -   非破坏性读出
    -   不需要重写
    -   不需要额外的刷新电路
    -   易失
    -   速度快，集成度低，功耗和价格较高
    -   常用作Cache
    -   同时送行列地址
-   DRAM
    -   以单个MOS管（栅极电容）为基本存储单元
    -   破坏性读出
    -   需要重写
    -   需要不断进行刷新操作
    -   易失
    -   速度慢，集成度高，功耗和价格较低
    -   常用作主存
    -   分两次送行列地址（地址线复用技术，导致地址线、地址引脚减半）

## SRAM

### 基本的静态存储元阵列

![image-20240601140605200](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601140605200.png)

对于任意一个SRAM，都有三组信号线

-   地址线，上图中的$A_0-A_5$，它指定了存储器的容量为$2^6$个存储单元。

-   数据线，上图中的$I/O_0-I/O_4$，说明存储器的字长是4为。

    因此存储位元的总数为$64\times 4 = 256$

-   控制线，上图中的$R/\overline{W}$。

    当$R/\overline{W}$为高电平，表示读

    当$R/\overline{W}$为低电平，表示写

    读写操作不会同时发生。

地址译码器的输出有64条选择线，称为行线。作用为打开每个存储位元的输入与非门。

### 基本的SRAM逻辑结构

SRAM采用双译码方式，采用二级译码。将地址分为x向，y向两部分。第一级进行x向和y向的独立移码，然后在存储阵列中完成第二级的交叉译码。

-   读写互斥

    ![image-20240601141818249](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601141818249.png)

$\overline{CS}$为片选信号。低电平有效时，门$G_1,G_2$均被打开。

$\overline{OE}$为读出使能信号。低电平有效时，门$G_2$开启。

$\overline{WE}$为写命令。

当$\overline{WE} = 1$，失效，门$G_1$关闭，存储器进行读操作；

当$\overline{WE} = 0$，有效，门$G_1$开启，存储器进行写操作。

从而保证了读写互斥。

### SRAM 读/写时序

在读周期中，地址线先有效，从而进行地址译码，选中存储单元。

为了读数据，片选信号和读出使能信号也必须有效（让其变为低电平）。

从地址有效开始，经过$t_{AQ}$（读出）时间，数据总线I/O上出现了有效的读出数据。

之后片选信号和读出使能信号恢复高电平。

经过$t_{RQ}$之后，允许地址总线发生改变。$t_{RQ}$时间即为读周期时间。

![image-20240601142803398](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601142803398.png)

在写周期中，地址线先有效。

接着片选信号有效，写命令有效。

此时I/O上必须置写入数据。在$t_{WD}$​时间段将数据写入存储器。

撤销写命令和片选信号。

为了写入可靠，I/O线的写入数据需要有维持时间$t_{hD}$

且**片选信号的维持时间也比读周期长**。

$t_{WC}$时间称为写周期时间。

![image-20240601142955230](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601142955230.png)

为了控制方便，一般取$t_{RC}=t_{WC}$​，通常称为存取周期。

## DRAM

### DRAM的读写操作

![image-20240601143658815](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601143658815.png)

-   写

    写1到存储元时：输出缓冲器、刷新缓冲器关闭。输入缓冲器打开（$R/\overline{W}$为低）。输入数据$D_{IN} = 1$被送到存储元位线上（高电平）。行选线为高，打开MOS管，位线上的高电平给电容器充电，表示存储了1。

    写0到存储元时：输出缓冲器、刷新缓冲器关闭。输入缓冲器打开（$R/\overline{W}$为低）。输入数据$D_{IN} = 0$​被送到存储元位线上（低电平）。行选线为高，打开MOS管，电容上的电荷通过MOS管和位线放电，表示存储了0。

-   读

    输入缓冲器、刷新缓冲器关闭，输出缓冲器/读放打开（$R/\overline{W}$为高）。行选线为高，打开MOS管。

    若当前存储的信息为1，则电容上所存储的1送到位线上，通过输出缓冲器/读出放大器发送到$D_{OUT}$，即$D_{OUT}=1$​。

-   刷新（重写）

    读出1后，输入缓冲器关闭，刷新缓冲器打开，输出缓冲器/读放打开。

    读出的数据$D_{OUT}$​又经刷新缓冲器送到位线上，再经MOS管写到电容上，存储元重写1。

输入缓冲器与输出缓冲器总是互锁的。

### 基本的DRAM逻辑结构

相比于SRAM，增加了行地址锁存器和列地址锁存器。地址分为行、列分时传送。

$\overline{RAS}$为行选通信号，$\overline{CAS}$为列选通信号。片选信号的功能也由新增的这两个信号来实现。

### DRAM读/写时序

在读周期中，当地址线上行地址有效后，使用行选通信号打入行地址锁存器。

接着地址线上传送列地址，使用列选通信号打入列地址锁存器。

经过行列译码，读写命令$R/\overline{W} = 1$，数据线上便有输出数据。 

![image-20240601145401229](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601145401229.png)

在写周期中，同上，读写命令变为0，在此期间，数据线上必须送入欲写入的数据$D_{IN}$

每个读周期或者写周期是从行选通信号下降沿开始，到下一个行选通信号的下降沿为止的时间。

### DRAM的刷新操作

未读写的存储元也要定时刷新。当前主流的DRAM器件的刷新间隔时间（**刷新周期**）为64ms。

集中式刷新策略：每一个刷新周期中集中一段时间对DRAM的所有行进行刷新。存在死时间。

分散式刷新策略：每一行的刷新操作被均匀地分配到刷新周期内。

通过存储器控制器或者DRAM控制器产生DRAM访问和刷新时序控制与地址信号。

刷新与存取不能并行。

# 存储器容量的扩展

$所需芯片个数 = \frac{设计要求的存储器容量}{已知芯片的存储容量}$

## 字长位数扩展法（位扩展）

若给定的芯片的**字数符合要求，但位数较短**，则需要进行位扩展，让**多片给定芯片并行工作**。

三组信号线中，地址线和控制线公用（多个RAM芯片使用相同的地址信号、控制信号）而数据线单独分开连接（分别接到数据总线的对应位）。

>   例：$利用多片1M\times 4位的SRAM芯片设计一个存储容量为1M\times 8位的SRAM存储器$
>
>   解：所需芯片数$d = (1M \times 8)/(1M \times 4) = 2 (片)$
>
>   ​	连接的三组信号线中，地址线、控制线公用。数据线分为高4位、低4位，分别与两片SRAM芯片的I/O端相连接。两片同时工作。
>
>   ​	地址线：存储器10根，芯片10根
>
>   ​	数据线：存储器8根，芯片4根
>
>   ​	控制线：读写控制、使能控制
>
>   ![image-20240601152247546](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601152247546.png)

## 字存容量扩展（字扩展）

若给定的芯片存储容量较小（字数少），不满足设计要求总存储容量，则需要进行字扩展，让**多片给定芯片分时工作**。

三组信号线中，给定芯片的地址总线和数据总线公用，读写控制信号线公用，由地址总线的高位译码产生片选信号，让各个芯片分时工作。

>   例：$利用16K\times 8位的存储器芯片构成64K\times 8位的存储器$
>
>   所需芯片数量$(64K\times8)/(16K\times 8) = 4 (片)$
>
>   地址线：存储器16位，芯片14位。高两位地址用于选择芯片。
>
>   数据线：存储器8位，芯片8位
>
>   控制线：读写控制。片选由高位地址经译码进行控制。

## 字位扩展

先进行位扩展，再进行字扩展。

各芯片的片内地址线、读/写控制线均对应地并接在地址和控制总线的对应位上；

由高位地址（n位）译码产生$2^n$个片选信号，决定芯片分成$2^n$个组；

由数据线决定每组的芯片片数。

>   例：用2114芯片（1K×4位）组成4K×8位存储器。
>
>   解：所需芯片数：8片
>
>   地址线：
>
>   4K = 2^12，所以共12根地址线。
>
>   存储器12位A11～A0；2114芯片10位A9～A0
>
>   ​                高两位地址A11、A10用于选择芯片
>
>   
>
>   数据线：
>
>   组成8位，则数据线共8根。
>
>   存储器8位；芯片4位。
>
>   ​                两片2114的数据线分别连接D7～D4和 D3～D0
>
>   ​                将2114芯片分为4组，每组2片芯片。
>
>   控制线：
>
>   读写控制；片选由高位地址经译码进行控制

# 只读存储器ROM

只读存储器ROM，其中存储的原始数据必须在它工作前写入。

-   掩膜ROM：存储内容固定的ROM，由生产厂家提供产品
    -   可靠性、集成度高，形成批量之后价格便宜
    -   用户对制造厂的依赖性过大，灵活性差
-   可编程ROM：用户后写入内容，有些课多次写入
    -   一次性编程：PROM
    -   多次编程：EPROM和$E^2PROM$
        -   EPROM：光擦除可编程可读存储器。当需要更新时，将原存储内容抹去，再写入新的内容。
        -   $E^2PROM$​：电擦除可编程只读存储器。其存储元是具有两个栅极的NMOS管。

# 闪存存储器

FLASH存储器：是高密度非易失性的读/写存储器。它具有巨大比特数目的存储容量。在EPROM存储元基础上发展起来。

-   编程操作
-   读取操作
-   擦除操作

在某一时间内只有一条行选择线被激活。

# 并行存储器

## 双端口存储器

同一个存储器具有两组相互独立的读写控制电路。进行并行的独立操作，因而是一种高速工作的存储器。

**空间并行**

-   无冲突的读写控制

    两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突。

    当任一端口被选中驱动时，就可对整个存储器进行存取。每一个端口都有自己的片选控制和输出驱动控制。

    读操作时，端口的$\overline{OE}$打开输出驱动器，由存储矩阵读出的数据就出现在I/O线上。

-   有冲突的读写控制

​	当两个端口同时存取存储器同一存储单元，而且至少有一个端口为写时，便发生**读写冲突**。

​	设置$\overline{BUSY}$标志。优先写，对另一个端口置$\overline{BUSY}$为低电平。读操作对$\overline{BUSY}$为低电平的端口失效。一旦优先端口完成了写操作，才开放延迟端口的读操作。

​	当两个端口均为开放状态（$\overline{BUSY}$为高电平），且存取地址相同时，发生**写冲突**。此时仲裁逻辑需要判断对哪个端口进行存取：

 -    $\overline{CE}$判断：如果地址匹配且在$\overline{CE}$前有效，片上的控制逻辑在$\overline{CE_L}$和$\overline{CE_R}$之间进行判断来选择端口

 -    地址有效判断：如果$\overline{CE}$在地址匹配之前变低，片上的控制逻辑在左、右地址间进行判断来选择端口

      无论选择哪种方式，$\overline{BUSY}$标志都将置位，从而关闭此端口，直到允许存取的端口完成操作时，才进行复位而打开此端口。

## 多模块交叉存储器

**时间并行**

一个由若干模块组成的主存储器是线性编址的。这些地址在各模块中如何安排，有**顺序方式**和**交叉方式**。

### 顺序方式

以下图为例，存储器的32个字可由5位地址寄存器指示

高2位选择4个模块中的1个；低3位选择每个模块中的8个字。

-   在顺序方式中某个模块进行存取时，其他模块不工作。而某一模块出现故障时，其他模块可以照常工作。

通过增添模块来扩充存储器容量也比较方便。

-   各模块一个接一个串行工作，因此存储器的带宽受到了限制

![image-20240601161457328](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601161457328.png)

### 交叉方式

低2位选择4个模块中的1个；高3位选择每个模块中的8个字。

连续地址分布在相邻的不同模块内，而同一个模块内的地址都是不连续的。

对连续字的成块传送，交叉方式的存储器可以实现多模块流水式并行存取，大大提高存储器的带宽。由于 CPU 的速度比主存快，假如能同时从主存取出 n 条指令，这必然会提高机器的运行速度。

![image-20240601161725977](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601161725977.png)

### 多模块交叉存储器的基本结构

以四模块交叉存储器为例。

![image-20240601162011805](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601162011805.png)

主存被分成4个相互独立、容量相同的模块 M0、M1、M2、M3，每个模块都有自己的读写控制电路、地址寄存器和数据寄存器，各自以等同的方式与 CPU 交换信息。

CPU同时访问四个模块，由存储器控制部件控制它们分时使用数据总线进行信息传递。

各模块的读写过程将重叠进行，所以多模块交叉存储器是一种**并行存储器结构**。

进行定量分析：

假设模块存取一个字的存储周期为$T$，总线传送周期为$\tau$，存储器的交叉模块数为$m$。为了实现流水线方式存取，应当满足$T \leq m\tau$。

$m$的最小值$m_min = T/\tau$称为**交叉存取度**。交叉存储器要求其模块数必须大于或等于$m_{min}$，以保证启动某模块后经$m\tau$时间再次启动该模块时，它的上次存取操作已完成。那么，连续读取$m$个字所需的时间为$t_1 = T + (m-1)\tau$

而顺序方式存储器连续读取$m$个字所需的时间为$t_2=mT$

从而可以看出交叉存储器的带宽确实大大提高了。

![image-20240601162626647](./3%20%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.assets/image-20240601162626647.png)

# cache存储器

## cache基本原理

目的：解决CPU和主存之间速度不匹配

原理：基于程序运行中具有的空间局部性和时间局部性特征

组成：由SRAM、控制逻辑组成

​	若cache在CPU芯片外，它的控制逻辑一般与主存控制逻辑合成在一起，称为主存/cache控制器

​	若cache在CPU内，则由CPU提供它的控制逻辑

特点：对程序员透明

---

CPU与cache之间的数据交换以**字**为单位，cache与主存间的数据传送以**数据块**为单位。一个块由若干字组成。

CPU读取内存中一个字时，发出此字的内存地址到cache和主存。若此字在cache中，则cache命中，此字立即传送给CPU；否则，cache缺失，用主存读周期将**此字**从主存读出送到CPU，与此同时，把**含有这个字的整个数据块**从主存读出送到cache中。

cache写操作：

-   写直达法：写操作时既写入cache又写入主存。写操作时间就是访问主存的时间。
-   写回法：写操作时只把数据写入cache而不写入主存。当cache数据被替换出去时才写回主存。写操作时间就是访问cache的时间。

## cache的命中率

从 CPU来看，增加 cache 的目的，就是在性能上使**主存的平均读出时间**尽可能接近 **cache 的读出时间**。

设$N_c$表示cache完成存取的总次数，$N_m$表示主存完成存取的总次数，$h$定义为命中率。则$h = \frac{N_c}{N_c+N_m}$

若$t_c$表示命中时的cache访问时间，$t_m$表示未命中时的主存访问时间，$1-h$表示缺失率。则cache/主存系统的平均访问时间$t_a$为

$t_a = ht_c+(1-h)t_m$

设$r=t_m/t_c$，表示主存与cache的访问时间之比，$e$表示访问效率，则有

$e = \frac{t_c}{t_a} = \frac{1}{h+(1-h)r}$

从上式可以看出，为了提高访问效率，命中率$h$越接近1越好，$r$​值为5~10为宜

## 主存与cache的地址映射

### 全相联映射

将主存中一个块的地址（块号）和块的内容（字）一起存于cache的行中，其中块地址存于cache行的标记（tag）部分中。这种带全部块地址一起保存的方法，可以使主存的一个块直接复制到cache中的任意一行上。

多对多

CPU访存指令指定了一个主存地址，为了快速检索，指令中的块号与cache中所有行的标记同时在比较器中进行比较。如果块号命中，则按字地址中cache中读取一个字；如果块号未命中，则按主存地址从主存中读取这个字。全部标记用一个**相联存储器**来实现，全部数据存储用一个普通RAM来实现。

优点：冲突概率小，cache的利用高

主要缺点：高速比较器电路难于设计和实现

应用场合：只适合于小容量cache采用。

转换公式：

-   主存地址长度=(s+w)位
-   寻址单元数=$2^{(s+w)}$个字或字节
-   块大小=行大小=$2^w$个字或字节
-   主存的块数=$2^s$
-   cache的行数 不由地址格式确定
-   标记大小=$s$位

>   例：
>
>   有一个存储体系，主存容量1MB，字长1B，块大小16B，cache容量64KB.
>
>   采用全相联映射，对内存地址(F0010)H给出相应的标记和字号。
>
>   **其实就是算s和w**
>
>   解：
>
>   块大小=行大小=$2^w$字节=16B
>
>   w=4
>
>   主存容量=主存寻址单元数=1M=$2^{20}$,$s+w=20$
>
>   s=16
>
>   (F0010)H=(1111 0000 0000 0001 0000)2
>
>   对应的标记=(1111 0000 0000 0001)2
>
>   字号=(0000)2

### 直接映射

一个主存块只能拷贝到cache的一个特定行位置上取。cache的行号i和主存的块号j有如下函数关系：

i = j mod m

式中，m为cache中的总行数。

将 s 位的主存块地址分成两部分：低 r 位主存区内块号作为 cache 的行地址，s–r 位区号作为标记(tag)与块数据一起保存在该行。当 CPU 以一个给定的内存地址访问 cache 时，首先用 r 位**区内块号**找到 cache 中的**特定一行**，然后用地址中的 s–r 位区号部分与此行的标记在比较器中做比较。若相符即命中，在 cache 中找到了所要求的块，而后用地址中最低的 w 位读取所需求的字。若不符，则未命中，由主存读取所要求的字。

优点：比较电路少m倍线路，所以硬件实现简单，Cache地址为主存地址的低几位，不需变换。

缺点：冲突概率高（抖动）

应用场合：适合大容量cache

转换公式：

-   主存地址长度=(s+w)位
-   寻址单元数=$2^{(s+w)}$个字或字节
-   块大小=行大小=$2^w$个字或字节
-   主存的块数=$2^s$
-   cache的行数=m=$2^r$
-   标记大小=$s-r$位
-   主存区内块号=cache行号

### 组相联映射

前两者的结合。cache分组，组间采用直接映射，组内采用全相联映射。

比全相联容易实现，冲突低 

cache分组u，组内容量v。

映射方法：一对多，q = j mod u。主存第j块内容拷贝到cache的q组中的某行。

v=1，则为直接相联映射方式 

u=1，则为全相联映射方式 

v的取值一般比较小， 一般是2的幂，称之为v路组相联cache.

转换公式：

-   主存地址长度=(s+w)位
-   寻址单元数=$2^{(s+w)}$个字或字节
-   块大小=行大小=$2^w$个字或字节
-   主存的块数=$2^s$​
-   每组的行数=v
-   组号的位数=d，组数u=$2^d$
-   cache的总行数=uv
-   标记大小=$(s-d)$​位

## 替换策略

LFU 最不经常使用

LRU 最近最少使用

随机替换

# 补充知识

## 译码器

-   译码：编码的逆过程，把输入的二进制代码翻译成所对应的控制信号和信息

-   译码器：实现译码功能的数字电路

    输入n位二进制代码，输出m个代表代码原意的信号。$m \leq 2^n$​，从而保证对应一组输入代码，有且仅有一个输出与之对应。

### 译码器的分类

-   二进制译码器

    输入端为$n$个，则输出端为$2^n$个。且对应于输入代码的每一种状态。$2^n$​个输出中只有一个为1（或为0），其余全为0（或为1）。（按我的理解，也就是类似于独热编码）

-   2-10进制译码器

-   显式译码器

    