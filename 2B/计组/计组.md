# 1 概论

## 计算机的分类

- 模拟计算机：模拟运算器件构成，变量由连续量来表示，运算过程连续。

    - 专用计算机：最有效、最经济、最快速的计算机，适应性差

    - 通用计算机：适应性强，牺牲了效率、经济和速度

        通用计算机的分类

        ![image-20240518113439421](./%E8%AE%A1%E7%BB%84.assets/image-20240518113439421.png)

- 电子数字计算机：逻辑电子器件构成，变量为开关量，数字式按位运算，运算模式离散。

| 比较内容       | 数字计算机 | 模拟计算机       |
| -------------- | ---------- | ---------------- |
| 数据表示方式   | 数字0和1   | 电压、电流等     |
| 计算方式       | 数字计算   | 电量组合和测量值 |
| 控制方式       | 程序控制   | 模拟信号组合控制 |
| 精度、抗干扰性 | 高、好     | 低、差           |
| 数据存储量     | 大         | 小、几乎无       |
| 逻辑判断能力   | 强         | 无               |

## 计算机发展史

| 年份      | 特点                           | 代表       |      |
| --------- | ------------------------------ | ---------- | ---- |
| 1946-1957 | 电子管计算机(ENIAC)            | 数据处理   |      |
| 1958-1964 | 晶体管计算机                   | 工业控制   |      |
| 1965-1971 | 中小规模集成电路计算机         | 小型计算机 |      |
| 1972-1990 | 大规模和超大规模集成电路计算机 | 微型计算机 |      |
| 1991-     | 巨大规模集成电路计算机         | 单片机     |      |

## 计算机性能指标

- 吞吐量：某一时间间隔内能够处理的信息量 字节/秒 B/S
- 响应时间：从输入有效到系统产生响应之间的时间度量 微秒/纳秒
- 利用率：给定时间间隔内，系统被实际使用的时间所占的比率，用百分比表示
- 处理机字长：运算其中一次能够完成二进制数运算的位数。8/16/32/64位。直接决定运算的精度和能力
- 总线宽度：CPU中运算器与存储器之间进行互连的内部总线二进制位数
- 存储器容量：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示

- 存储器带宽：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，用字节数/秒表示

- 主频：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz（兆赫兹）、GHz（吉赫兹）。

- 时钟周期：主频的倒数，微秒/纳秒

- CPU执行时间：表示CPU执行一段程序所占用的CPU时间。

    CPU执行时间 = CPU时钟周期数 $\times$ CPU时钟周期长

- CPI：执行一条指令所需的平均始终周期数。

    $CPI = \frac{执行某段程序所需的CPU时钟周期数}{该程序包含的指令条数}$  

- MIPS：每秒百万条指令数

    $MIPS = \frac{指令条数}{程序执行时间 \times 10^6} = \frac{时钟频率}{CPI \times 10^6}$

- FLOPS：每秒浮点操作次数。基于操作而非指令，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。

    $FLOPS = \frac{程序中的浮点操作次数}{程序执行时间}$  

- MIPS：单位时间内的执行指令数。MIPS值越高，机器速度越快。

## 计算机的硬件

- 冯诺依曼型思想：存储程序、按地址自动执行
- 五大部件：控制器、运算器、存储器、输入设备、输出设备。

### 运算器

- 功能：处理所有的算数及逻辑运算
- 特点：采用二进制数据进行运算
- 构成：由ALU（算术逻辑单元）和各类通用寄存器构成。

### 存储器

- 功能：保存所有的程序和数据
- 特点：二进制形式保存程序和数据；存储器是按存储单元组织的，读写存储单元必须给出单元地址。
- 相关概念
    - 存储元：用于保存一位0/1二进制数据的物理器件
    - 存储单元：能够保存一个字数据的器件，由若干个存储单元构成
    - 单元地址：能够区分每一个存储单元的编号，一般从0开始编号
    - 存储容量：一个存储器所能保存的二进制信息的总量
- 分类
    - 外存（辅助存储器）：如磁盘存储器、光盘存储器；CPU不可直接访问
    - 内存（主存储器）：半导体存储器；CPU直接访问，存放当前系统运行所需的所有程序和数据
- 两个与主存相关的寄存器
    - MAR（存储器地址寄存器）：接收由CPU送来的地址信息。
    - MDR（存储器数据寄存器）：作为外界与存储器的数据通路。

### 控制器

- 功能：根据所要执行指令的功能，按顺序发出各种控制命令，协调计算机的各个部件的工作。

- 主要任务
    - 解释并执行指令
    - 控制指令的执行程序
    - 负责指令执行过程中，操作数的寻址
    - 根据指令的执行，协调相关部件的工作，如运算类指令执行时对标志寄存器的影响设置
- 指令的形式
    - 操作码：指出指令所进行的操作，如加、减、数据传送等
    - 地址码：指出进行以上操作的数据存放位置

### 适配器与输入输出设备

- 输入设备：将人们熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式的设备。
- 输出设备：把计算机的处理结果变成人或其他机器设备所能接收和识别的信息形式的设备。

- 适配器：保证外围设备用计算机系统特性要求的形式发送或接收信息。
- 系统总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路。

## 计算机的软件

计算机软件 = 程序 + 数据 + 文档

- 系统程序：用来简化程序设计，简化使用方法，提高计算机的使用效率，发挥和扩大计算机的功能及用途。

    >服务性程序，如诊断程序、排错程序、练习程序等；
    >
    >语言类程序，如汇编程序、编译程序、解释程序等；
    >
    >操作系统；
    >
    >数据库管理系统

- 应用程序：用户利用计算机来解决某些实际问题所编制的程序。

    > 工程设计程序、数据处理程序、自动控制程序、企业管理程序、情报检索程序、科学计算程序等等。

## 计算机的层次结构

计算机由5个以上不同的级组成，每一级都能进行程序设计。

| 级别 |     名称     |      对应      |
| :--: | :----------: | :------------: |
| 5级  |  高级语言级  |    编译程序    |
| 4级  |  汇编语言级  |    汇编程序    |
| 3级  |  操作系统级  |    操作系统    |
| 2级  |  一般机器级  |     微程序     |
| 1级  | 微程序设计级 | 直接由硬件执行 |

## 软件与硬件的逻辑等价性

任何操作可以由软件来实现，也可以由硬件来实现；任何指令的执行可以由硬件完成，也可以由软件来完成。

# 2 数据格式

- 定点格式：容许的数值范围有限，但要求的处理硬件比较简单
- 浮点格式：容许的数值范围很大，但要求的处理硬件比较复杂

## 定点表示法

约定机器中所有数据的小数点位置是固定不变的。通常将数据表示成纯小数或纯整数。

- 定点纯小数，小数点位于符号位之后，不需专门存放位置。

    $-1<X<+1$

    | 机器码                         | 表示的数      | 说明                                                    |
    | ------------------------------ | ------------- | ------------------------------------------------------- |
    | x = 0.00...0<br />x = 1.00...0 | 0             | 正负0                                                   |
    | x = 0.11...1                   | $1-2^{-n}$    | 能表示的最大的正数<br />相当于1.00...0(2) - 0.00...1(2) |
    | x = 0.00...01                  | $2^{-n}$      | 最接近0的正数                                           |
    | x = 1.00...01                  | $-2^{-n}$     | 最接近0的负数                                           |
    | x = 1.11...1                   | $-(1-2^{-n})$ | 最小负数                                                |

- 定点纯整数，小数点位于最后一位之后，不需专门存放位置。

​	$-(2^n-1)\leq X \leq +(2^n-1)$

## 浮点表示法

$N = R^E.M$

R：基数，取固定值，一般为2，隐含表示

E：指数，用移码

M：尾数，用原码

**IEEE754标准**规定了浮点数的表示格式，运算规则等。

![image-20240518121929084](./%E8%AE%A1%E7%BB%84.assets/image-20240518121929084.png)

数符S：0正1负

阶码E：含阶符的阶码，采用移码方式来表示正负指数

尾数M：尾数最高有效位为1，小数点放在尾数域最前面

- 真值为0的机器数：阶码E=0，尾数M=0。正0：S=0,负0：S=1.
- 无穷大的机器数：阶码E全1，尾数M=0。正无穷：S=0,负无穷：S=1.
- NaN：阶码E全1，尾数M != 0. 不是一个数，通知异常情况。

### 32位单精度浮点数规格化表示

$$
x = & (-1)^s\times (1.M) \times 2^e \\
e = & E - 127
$$

- E = 0000 0001 ~ 1111 1110 (1~254)

- e = -126 ~ +127

- 最小绝对值

    e=-126,M=0

​	1.M = 1

​	$1.0 \times 2^{-126} \approx 1.18 \times 10^{-38}$

- 最大绝对值

    e=127,M=11...1(23个1)

​	1.M = 1.11...1 = $2 - 2^{-23}$

​	$(2-2^{-23}) \times 2^{127} \approx 3.40 \times 10^{38}$

### 64位单精度浮点数规格化表示

$$
x = & (-1)^s\times (1.M) \times 2^e \\
e = & E - 1023
$$

- E = 1~2046

- e = -1022~+1023

- 最小绝对值

    e=-1022,M=0

​	1.M = 1

​	$1.0 \times 2^{-1022} \approx 2.23 \times 10^{-308}$

- 最大绝对值

    e=1023,M=11...1(52个1)

​	1.M = 1.11...1 = $2 - 2^{-52}$

​	$(2-2^{-52}) \times 2^{1023} \approx 1.79 \times 10^{308}$

> 例1：**浮点机器数** (41360000)16，求真值
>
> ![image-20240518124925859](./%E8%AE%A1%E7%BB%84.assets/image-20240518124925859.png)
>
> 例2：真值20.59375，求32位单精度浮点数
>
> ![image-20240518125153565](./%E8%AE%A1%E7%BB%84.assets/image-20240518125153565.png)

# 3 数的机器码表示

## 原码

正数：最前面加一个符号位

负数：最前面加一个符号位

## 反码

正数：不变

负数：与原码数值位相反

## 补码

正数：不变

负数：原负数加上模。

- 定点小数x0.x1x2…xn ，以2为模

- 定点整数x0x1x2…xn ，以2n+1为模

- 负数求补码的简单方法：

    1.求出负数**绝对值**的原码

    2.从原码的最后一位数码位往前数，当遇到第一个1时停在此位置

    3.将第一个1前面的数码（不包括这个1，**包括符号位**）全部求反


## 移码

$[X]_{移码} = 2^n + X \\ -2^n \leq X < 2^n$

最高位为符号位

> 例：
>
> [105]移码＝10000000＋01101001＝11101001
>
> [-105]移码＝10000000－01101001＝00010111

## 特殊/易错

1. 如果码长为8位：-128只有补码1000 0000，没有原码和反码。相当于-128+128=0，符号位1，结果1000 0000。同理，码长位16位，-32768只有补码1000 0000 0000 0000.

2. 0:

    ​	原码：+0：00000000 -0：10000000

    ​	反码：+0：00000000 -0：11111111

    ​	补码：+0：00000000 -0：00000000

# 4 定点加减法运算规则

- 计算机中均采用补码加减运算。参加运算的操作数均用补码表示并且运算结果也以补码表示。

- 符号位和数值位一样，一起参与运算。

- 补码总是对确定的模而言，若运算结果超过模(有从符号位上产生的进位)，则将模自动丢掉。

## 补码加法

两数的补码之和等于两数和的补码。

证明的关键点：假设x,y均为纯小数。

- 进位2可能丢失
-  2＋x＝ｘ补

> 证明：
>
> 假设︱ｘ︱﹤1, ︱ｙ︱﹤1, ︱ｘ＋ｙ︱﹤1，现分四种情况予以证明
>
> (1) x > 0, y > 0,则x+y>0
>
>   ∵ｘ﹥0,ｙ﹥0,
>
>   ∴ [ｘ]补=x, [ｙ]补=y
>
>   ∴ [ｘ]补+[ｙ]补=x+y
>
>   又∵ｘ＋ｙ﹥0
>
>   [ｘ＋ｙ]补=x+y 
>
>   ∴等式[ｘ]补+[ｙ]补= [ｘ＋ｙ]补成立. 
>
> (2) ｘ> 0,ｙ< 0,则ｘ＋ｙ>0或ｘ＋ｙ<0 
>
>    则有：[ｘ]补=x, [ｙ]补=2+y,
>
>    **∴**[ｘ]补＋[ｙ]补=x+ 2+y 
>
>    当ｘ＋ｙ>0时,2 ＋ (ｘ＋ｙ) > 2,进位2必丢失,
>
>    	又因(ｘ＋ｙ)>0， [ｘ＋ｙ]补＝ｘ＋ｙ
>	
>    	**∴** [ｘ]补＋[ｙ]补＝ｘ＋ｙ＝[ｘ＋ｙ]补　　　 
>
>    当ｘ＋ｙ<0时,2 ＋ (ｘ＋ｙ) < 2,
>
>   	 又因(ｘ＋ｙ)<0， [ｘ＋ｙ]补＝ 2＋(ｘ＋ｙ)
>	
>  	 故 [ｘ]补＋[ｙ]补＝2＋(ｘ＋ｙ)＝[ｘ＋ｙ]补
>
>    **∴**等式[ｘ]补+[ｙ]补= [ｘ＋ｙ]补成立
>
> (3) ｘ<0,ｙ>0,则ｘ＋ｙ>0或 ｘ＋ｙ<0 
>
> ​      这种情况和第（2）种情况一样,把ｘ和ｙ的位置对调即得证
>
> (4) ｘ<0,ｙ<0,则ｘ＋ｙ<0 
>
> ​    相加两数都是负数,则其和也一定是负数。 
>
> 　∵[ｘ]补＝2＋ｘ,　　　[ｙ]补＝2＋ｙ 
>
> 　∴[ｘ]补＋[ｙ]补＝2＋ｘ＋2＋ｙ＝2＋(2＋ｘ＋ｙ)
>
> 　 上式右边分为”2”和(2＋ｘ＋ｙ)两部分.
>
> ​     既然(ｘ＋ｙ)是负数,而其绝对值又小于1,那么(2＋ｘ＋ｙ)就一定是小于2而大于1的数,进位”2”必丢失.
>
> ​     又∵ (ｘ＋ｙ)<0
>
> ​     ∴ [ｘ]补＋[ｙ]补＝2＋(ｘ＋ｙ)＝[ｘ＋ｙ]补
>
> ​     ∴等式[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补成立

## 补码减法

两数补码之差等于两数差的补码

> 证明：
>
> ∵[x+y]补＝[x]补+[y]补
>
> ∴[x]补＋[－y]补＝[x－y]补
>
>  所以只要证明[－y]补＝－[y]补
>
>  则 [x]补－[y]补＝[x]补＋[－y]补＝[x－y]补即可成立。
>
>    ∵[x+y]补＝[x]补＋[y]补 
>
>    ∴**[y]补＝[x＋y]补－[x]补**
>
> ​    [x－y]补＝[x]补+[－y]补  
>
> ​    **∴[－y]补＝[x－y]补－[x]补**
>
>   ∴ **[y]补+[－y]补**＝[x＋y]补＋[x－y]补－[x]补－[x]补
>
> ​              ＝[x+y+x－y]补－[x]补－[x]补
>
> ​              ＝[x+x]补－[x]补－[x]补
>
> ​              ＝[x]补+[x]补－[x]补－[x]补＝0  
>
>    ∴ －[y]补＝[－y]补

## 溢出与溢出检测

- 上溢（正溢出）：两个正数相加的结果超出机器所能表示的最大正数。
- 下溢（负溢出）：两个负数相加的结果小于机器所能表示的最小负数。

### 检测方法

#### 双符号位法

- 变形补码：采用两个符号位的补码。

​	00 正确，正数

​	01 上溢

​	10 下溢

​	11 正确，负数

#### 单符号位法

与上面一样，只是最高位是符号位产生的进位，第二位是最高有效位产生。

# 5 基本的二进制加法/减法器

- 半加器：两数相加，不考虑低位进位
- 全加器：完成两个二进制数相加，考虑低位进位。（完成三个一位数相加的功能）

## 一位全加器FA

实现两个二进制数字$A_i,B_i$和一个进位输入$C_i$相加,产生一个本位和输出$S_i$,以及一个进位输出$C_{i+1}$​。

- 一位全加器真值表

| $A_i$ | $B_i$ | $C_i$ | $S_i$ | $C_{i+1}$ |
| ----- | ----- | ----- | ----- | --------- |
| 0     | 0     | 0     | 0     | 0         |
| 0     | 0     | 1     | 1     | 0         |
| 0     | 1     | 0     | 1     | 0         |
| 0     | 1     | 1     | 0     | 1         |
| 1     | 0     | 0     | 1     | 0         |
| 1     | 0     | 1     | 0     | 1         |
| 1     | 1     | 0     | 0     | 1         |
| 1     | 1     | 1     | 1     | 1         |

- 一位全加器逻辑表达式

$$
S_i & = A_i \oplus B_i \oplus C_i \\ C_{i+1} & = A_iB_i + A_iC_i + B_iC_i \\ & = A_iB_i + (A_i \oplus B_i)C_i
$$

​	*逻辑表达式可以变形，故电路形式不是唯一的*

- 一位全加器内部结构图

![image-20240518134844385](./%E8%AE%A1%E7%BB%84.assets/image-20240518134844385.png)

- $C_{i+1}相对于C_i延时为2T$
- $C_{i+1}相对于A_i延时为5T$
- $S_{i}相对于A_i延时为6T$

---

*补充：典型门电路的逻辑符号和时间延迟*

![逻辑门的种类与电路图介绍](./%E8%AE%A1%E7%BB%84.assets/R-C.7d4a14d582c20aa25fc6331d2d43f360rik=IbZrSux5I9sBVA&riu=http%253a%252f%252fwww.ejiguan.cn%252fuploadfile%252f2022%252f0214%252f20220214074310193.jpeg)

T被定义为相应于单级逻辑电路的单位门（“与”门或“或”门)延迟。异或延迟3T。

注：此处课本和网上资料与教学PPT不一致，PPT上为“与非”“或非”门延迟为T，“与”“或”延迟为2T.

---

- 串行加法：从低位开始，每步只完成一位运算的加法。
    - 只需要一个全加器和一个进位触发器。
    - 计算两个n位数之和，需要n+1步（1位符号位）或n+2步（2位符号位）运算。
    - 高位运算只有等低位运算完成后才能进行，速度较慢。
- 并行加法器：
    - 可在同一时刻完成n位数的运算
    - 若用变形补码表示一个机器数，则符号位2位，需要n+2个加法器
    - 速度比串行快很多，是用足够多的硬件设备换来的

## 行波进位补码加法/减法器

​	![行波进位加法器](./%E8%AE%A1%E7%BB%84.assets/0c30d26c155f766b28dc0abe5091b51.jpg)

- 考虑溢出时，延迟$t = n \times 2T + 9T$
- 不考虑溢出时，延迟$t = (n - 1) \times 2T + 9T$​
- M控制加减，单符号溢出检测

> 引用自[全加器以及行波进位加/减法器时延的计算 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/590151247)@[胡平](https://www.zhihu.com/people/hu-ping-70)
>
> - **输入减数和被减数**。开始进行计算（我们假定：数据的输入是瞬时的，时延是0T）。
> - **最低位的全加器的进位时延**。最低位的全加器的一个输入端需要等待取反异或门的输出，异或门的时延是3T；3T 之后，被减数到达全加器的输入端，从加器的输入端经过8T 的时延（3T的取反+5T的全加器进位）后，进位输出；9T （3T的取反+6T的全加器值输出）的时延后，最低位计算值输出。
> - **第2个到第N个全加器的进位计算**。当最低位的全加器输出进位的时候，**第2位到第N位**已经完成了被减数的取反的操作，所有全加器的两个输入端都已就绪，就差从低位的全加器中获取进位了。所以，对于剩余全加器，每个全加器输出**进位的时延不是5T，而是 2T。**
> - **整体计算结果的溢出判断**。这个只能等所有的全加器都完成进位之后才能得出，这个是异或门判断的，时延是3T，所以N 位减法器的总计算时延为：
> - **【最低位的取反输入异或门时延】** 3T **+ 【最低位的全加器进位时延】**5T **+ 【N-1个全加器的进位时延】**2T*(N-1) **+【溢出异或门时延】**3T

# 6 原码并行乘法

计算机中实现乘除运算通常采用以下三种方式：

- 利用乘除运算子程序

    基本思想是采用软件实现乘除运算。通常是利用计算机中的加/减运算指令、移位指令及控制类指令组成循环程序，通过在运算器中的加法器、移位器等基本部件上的反复加/减操作，得到运算结果。这种方式所需硬件简单，但实现速度较慢，主要应用在早期的小、微型机上。

- 在加法器的基础上增加左、右移位及计数器等逻辑线路构成乘除运算部件。

    在采用乘除运算部件实现乘除运算的计算机中，设置有乘除运算指令，用户只需执行乘除指令即可进行乘除运算。

- 用LSI和VLSI工艺实现专用的乘法器

    阵列乘除运算器将多个加减运算部件排成乘除运算阵列，依靠硬件资源的重复设置，同时进行多位乘除运算的乘除运算，赢得了乘除运算的高速度。

## 不带符号位的阵列乘法器

这种乘法器要实现n位×n位时,需要n(n－1)个全加器和$n^2$个“与”门。 

![image-20240518143240635](./%E8%AE%A1%E7%BB%84.assets/image-20240518143240635.png)

令$T_a$为与门的传输延时，$T_f$为FA的进位传输延时，$T_{fa}$为加延时（每级异或门3T，共6T）。

$T_a = T,T_f = 2T,T_{fa}=6T$

> $n \times n$延时：
> $$
> \begin{align}
> t & = T_a + (n-1)T_{fa} + (n-1)T_f + 3T \\
>   & =(8n-4)T
>   \end{align}
> $$

在做笔试计算题时，过程和算普通的乘法一模一样。

## 带符号的阵列乘法器

### 求补电路

输入E代表是否要求补。0代表不求补。1时求补，接符号位。

![img](./%E8%AE%A1%E7%BB%84.assets/afcd539b8c4152a65393aad81f08f85a.png)

用这种对2求补器来转换一个(n＋1)位带符号的数,所需的总时间延迟为：

$t_{TC} = n \times 2T + 5T = (2n+5)T$

### $(n+1) \times (n+1)$位带求补器的阵列乘法器

- 原码乘，$a_n,b_n$接0，不求补。
- 补码乘，$a_n,b_n$​接符号位，求补。时间比原码乘大1倍。
- 补码乘中，输入端的求补电路是将补码转换为绝对值，输出端的求补电路是将绝对值转换为补码，符号位单独处理，增加在高位。

![image-20240518150632908](./%E8%AE%A1%E7%BB%84.assets/image-20240518150632908.png)

> 例1：
>
> ![](./%E8%AE%A1%E7%BB%84.assets/image-20240518150801274.png)
>
> 例2：
>
> ![image-20240518150824154](./%E8%AE%A1%E7%BB%84.assets/image-20240518150824154.png)

### 尾数规格化

   在规格化浮点运算中，若运算结果不是规格化数，必须进行规格化处理。

- 原码表示中：

    满足$\frac{1}{2} \leq |M| < 1$​的数为规格化数。即有效位最高位必须为1。

    0.1xx...x

    1.1xx...x

- 补码表示中：

    满足$-1 \leq M < - \frac{1}{2}$ 或  $\frac{1}{2} \leq M < 1$。即符号位和有效位最高位必须不同。​

    00.1xx...x

    11.0xx...x

- 把尾数变成规范化的格式——移位。同时调整阶数从而保证数值本身不变，左规阶数-1，右规阶数+1。

    原码：

    > 例：
    >
    > | 不规范数 | 规范数 | 方法 | 补0/1 | 阶码变化 |
    > | -------- | ------ | ---- | ----- | -------- |
    > | 0.0101   | 0.1010 | 左规 | 低位0 | -1       |
    > | 1.0101   | 1.1010 | 左规 | 低位0 | -1       |

    补码：

    > 例：
    >
    > | 不规范数 | 规范数   | 方法 | 补0/1 | 阶码变化 |
    > | -------- | -------- | ---- | ----- | -------- |
    > | 1.1101   | 1.0100   | 左规 | 低位0 | -2       |
    > | 11.1001  | 11.0010  | 左规 | 低位0 | -1       |
    > | 01.0101  | 00.10101 | 右规 | 高位0 | +1       |
    > | 10.0101  | 11.00101 | 右规 | 高位1 | +1       |

​	**总之就是把不规范的变成规范的样子，右移就+阶码，左移就-阶码**

# 7 原码除法算法原理

[原码除法 恢复余数法和不恢复余数法(加减交替法) 计组_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1DY4y177dV/?spm_id_from=333.337.search-card.all.click&vd_source=699b6cd17476125e966cc1c30dec1f32)

- 小数定点除法对被除数和除数有一定的约束，必须满足：∣被除数∣<∣除数∣

- 具有n位尾数的合法除法，需要逻辑移位n次，上商n+1次
- 若最后一次所得的余数为负，要加上y的绝对值的补码。
- 左移了几次，最后的余数要乘以2的负几次方。

## 恢复余数法

直接作减法试探方法，不管被除数(或余数)减除数是否够减，都一律先做减法。若余数为正，表示够减，该位商上“1”，余数左移（等价于被除数右移）；若余数为负，表示不够减，该位商上“0”，并要恢复原来的余数（将刚刚减掉的被除数加回去），然后余数左移。

符号位单独考虑，所以需要用到x绝对值的补码，y绝对值的补码以及-y的补码（做减法）。**做运算中一直用的是补码，减法时用-y的补码。**

若所得余数为正，表示够减，商1，余数左移1位，**减去**除数。

若所得余数为负，表示不够减，商0，余数**加上**除数，然后再左移1位，**减去**除数。



## 不恢复余数法

在恢复余数法中，若余数$r<0$，需要恢复余数，进行相加$(r+y)$，左移$(\times 2)$，减除数$(-y)$, 最终结果为$2(r+y)-y$。将这个数变换一下，得到$2r+y$​。

也就是说，**“余数加上除数，然后再左移1位，再减去除数。”**和**“余数左移1位，加上除数”**是等价的。

所以在恢复余数法中的这一步，可以简化成左移$(\times 2)$，相加$(+y)$​

若所得余数为正，表示够减，商1，余数左移1位，**减去**除数。

若所得余数为负，表示不够减，商0，余数左移1位，**加上**除数。

# 8 并行除法器

利用若干个加减单元组成阵列，将各步加／减、移位操作在一个节拍内完成，从而提高除法运算速度。

## 可控加法/减法（CAS）单元

![image-20240518162810608](./%E8%AE%A1%E7%BB%84.assets/image-20240518162810608.png)

有四个输出端和四个输入端:

当P＝0时,CAS作加法运算

当P＝1时,CAS作减法运算
$$
S_i = A_i \oplus (B_i\oplus P)\oplus C_i \\
C_{i+1} = (A_i + C_i) · (B_i \oplus P) + A_iC_i
$$

> 逻辑运算中，异或1相当于取反，异或0相当于不变。

CAS单元的实际内部电路用一个三级组合逻辑电路(包括反向器)来实现。因此**每一个基本的CAS单元的延迟时间为3T**

## 不恢复余数法的阵列除法器

![image-20240518163152465](./%E8%AE%A1%E7%BB%84.assets/image-20240518163152465.png)

对一个2n位除以n位的不恢复余数阵列除法器来说，单元的数量为$(n+1)^2$，除法执行时间为$3(n+1)^2T$
