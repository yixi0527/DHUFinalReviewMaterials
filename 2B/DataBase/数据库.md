# 数据库期末复习

[TOC]

# 1 数据库概论

## 数据库的由来和发展

四个阶段：人工管理、文件系统、数据库阶段、高级数据库阶段。

### 人工管理

特点：数据不保存在计算机内；没有专用的软件对数据进行管理；只有程序的概念，没有文件的概念；一组数据对应一个程序（数据面向程序）。

### 文件系统阶段

特点：

- 数据以文件的形式保存在外部存储器的磁盘上
- 数据的逻辑结构和物理结构有了简单区别
- 文件组织多样化
- 数据不再属于某个特定的程序（数据面向应用）
- 对数据的操作以记录为单位。

缺陷：

- 数据冗余
- 数据不一致
- 数据联系弱

### 数据库阶段

- 采用数据模型表示复杂的数据结构
- 有较高的数据独立性
- 数据库系统为用户提供了方便的用户接口
- 四方面的控制功能
    - 数据库的恢复
    - 数据库的并发控制
    - 数据的完整性
    - 数据安全性

- 增加了系统的灵活性

### 高级数据库阶段

- 对象数据库技术

- 分布式数据库系统
- 开放数据库互联技术
- XML数据库技术
- 现代信息集成技术

## 数据描述

概念设计与逻辑设计的对应关系

| 概念设计   | 逻辑设计       |
| ---------- | -------------- |
| 实体       | 记录           |
| 属性       | 字段（数据项） |
| 实体集     | 文件           |
| 实体标识符 | 关键码         |

物理数据描述：数据在存储设备上的存储方式的描述，物理数据是实际存放在存储设备上的数据。

逻辑数据描述：程序员或用户以操作的数据形式的描述，是抽象的概念化数据。

## 数据抽象的级别

- 概念模型：表达用户需求观点的数据全局逻辑结构的模型。实体联系模型属于概念模型。

- 逻辑模型：表达计算机实现观点的DB全局逻辑结构的模型。层次模型、网状模型、关系模型、对象模型
    - 表达了DB的整体逻辑结构
    - 从数据库实现的观点出发对数据建模
    - 独立于硬件，依赖于软件
    - 数据库设计人员与应用程序员之间进行交流的工具

- 外部模型：表达用户使用观点的DB局部逻辑结构的模型
    - 是逻辑模型的一个逻辑子集
    - 独立于硬件、依赖于软件
    - 反映了用户使用数据库的观点
    - 简化了用户的观点
    - 有助于数据库的安全性保护
    - 对概念模型的支持

- 内部模型：表达DB物理结构的模型

    - 又称物理模型
    - 数据库最底层的抽象

    四种模型的关系：

![四种模型的关系](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/145a773952a56300fd5df8e675d22f2-1715958103869-2.jpg)

### 三层模式，两级映像

三层模式：外模式、（逻辑）模式、内模式

- 外模式：用户与数据库系统的接口，用户用到的那部分数据的描述。由若干个外部记录类型组成。
- 逻辑模式：数据库中全部数据的整体逻辑结构的描述。由若干个逻辑记录类型组成，还包括记录间联系、数据的完整性和安全性等要求。
- 内模式：数据库在物理存储方面的描述。定义所有内部记录类型、索引和文件的组织方式以及数据控制方面的细节。

两级映像：三层模式之间的影响，来说明外部记录、逻辑记录和内部记录之间的对应性。

- 两个映像分别在外模式、内模式中描述（而不在逻辑模式中）。

### 高度的数据独立性

数据独立性：应用程序和数据库的数据结构之间相互独立，不受影响。在修改数据结构时，尽可能不修改应用程序。分为物理数据独立性和逻辑数据独立性。

一般说来，关系数据库系统在支持数据独立性方面优于层次、网状系统。

## 数据库管理系统

### DBMS的工作模式

根据**数据模型**的不同，DBMS可以分成：层次型、网状型、关系型、对象型等。

### DBMS的主要功能

- 数据库定义：提供三层结构、两级映像，定义数据的完整性约束、保密限制等约束。（DDL）
- 数据库的操纵：查询和更新（插入、删除、更新）（DML）
- 数据库的保护：数据库的恢复、并发控制、数据完整性控制、数据安全性控制。
- 数据库的维护：数据载入、转换、转储，数据库的改组及性能监控。
- 数据字典。

# 2 关系模型和关系运算理论

## 基本概念

关系模型：用二维表格表示实体集，用关键码表示实体之间联系的数据模型。

元数：关系中属性的个数。

元组：每一行。

基数：元组个数。

各种键：

- 超键：关系中能唯一表示元组的属性或数据集。（超键= 候选键+ 任意其他属性）
- 候选键：不含有多余属性的超键。
- 主键：用户选座元组标识的候选键。
- 外键：模式R中属性K是其他模式的主键，则K在R中是外键。

关系：每一个属性值不可分解，不允许出现重复元组，不考虑元组间的顺序，属性无序

### 关系模型的3类完整性规则

- 实体完整性规则：主键的属性上不能有空值。
- 参照完整性规则：不允许引用不存在的实体。（外键）
- 用户定义的完整性规则：例如，用户定义年龄在15~30岁之间。

### 关系模型的3层体系结构

- 关系模式：由DDL定义，不涉及物理存储方面的描述，仅仅描述数据本身的一些特性。
- 子模式：用户所用到的那部分数据的描述，需定义用户对数据进行操作的权限。
- 存储模式：关系存储时作为文件看待。

### 关系模型的3个组成部分

- 数据结构：数据库中全部数据及其相互联系被组织成“关系”（二维表格）的形式。关系模型的基本数据结构是关系。
- 数据操纵：关系模型提供一组完备的高级关系运算。关系运算分为关系代数、关系演算和关系逻辑。
- 数据完整性规则：必须满足实体完整性、参照完整性和用户定义的完整性3类完整性规则。

### 关系查询语言和关系运算

DML分为查询语句和更新语句。关于查询的理论称为关系运算理论。

- 关系代数语言：查询操作是以**集合操作**为基础的运算
- 关系演算语言：查询操作时以**谓词演算**为基础的运算
- 关系逻辑语言：查询操作是以**if-then逻辑**操作为基础的运算

## 关系代数

### 5个基本操作

- 并 $\cup $

- 差 $- $

- 笛卡尔积（交叉连接） $\times $

    > AxB={<x,y>|x∈A∧y∈B}
    > 例如，A={a,b},B={0,1,2},则
    > AxB={<a,o>,<a,1>,<a,2>,<b,0>,<b,1>,<b,2>,}
    > BxA={<0,a>,<0,b>,<1,a>,<1,b>,<2,a>,<2,b>}
    >
    > ![387d06d244b8dad27150538f5db8cec](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/387d06d244b8dad27150538f5db8cec.jpg)

- 投影 $\pi $ 


>  $\pi_{i}(R) $ 在R表中取 $i $​列

- 选择$\sigma$

    根据条件对关系做水平分割，选取符合条件的元组。

### 4个组合操作

- 交 $\cap $

- 连接 $\mathop{\bowtie}\limits_{i\theta j} $

    > 从笛卡尔积中选取属性值满足某一 $\theta $操作的元组
    >
    >  $\theta $为 $= $​​时称为等值连接。
    >
    >  $\theta $下方的 $i,j $可以为列的序号，也可以是列名
    >
    > ![](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/1a6b778ba22f6acc8e66cfec0833eca.jpg)

- 自然连接 $\bowtie $

    消除了公共属性的笛卡尔积。（如下图，不再是R.B,S.B,而是B）

​	![3f04223b29d0249ed54dcbc9aa13933](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/3f04223b29d0249ed54dcbc9aa13933.jpg)

- 除法（不考）

实例：
$$
\pi_{SID,SNAME}(\sigma_{TNAME='LIU'}(S\bowtie SC \bowtie C \bowtie T))
$$

### 7个扩充操作

- 改名（不考）
- 广义投影
- 赋值
- 外连接 R⟗S
    - 外连接，将自然连接中原本舍弃的元组保留⟗
    - 左外连接，只将自然连接中R中原该舍弃的保留⟕
    - 右外连接，只将自然连接中S中原该舍弃的保留⟖
    - ![f8e9aaa448cecf7a2a329dbbb695a81](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/f8e9aaa448cecf7a2a329dbbb695a81.jpg)

- 外部并

    - 不要求关系模式相同

    - 构建出的新关系由R,S的所有属性组成，公共属性只取一次，新的元组由属于R或属于S的元组构成，新的属性上填上空值。

        ![02eaebc16456f39112957aadfa29cad](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/02eaebc16456f39112957aadfa29cad.jpg)

- 聚集操作

    - 输入一个值的集合，得到一个单一的值作为结果。

        >  $count_{SID}(\sigma_{age='18'}(S)) $

### 关系代数的启发式优化算法

- 早选择

- 早投影

- 避免直接做笛卡尔积

    ![8241e747898c612d938d68d34067edb](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/8241e747898c612d938d68d34067edb.jpg)

    ![d208c9ae5e735e4450828e487f83bec](./%E6%95%B0%E6%8D%AE%E5%BA%93.assets/d208c9ae5e735e4450828e487f83bec.jpg)

    经验之谈：一般 $\sigma $后可能都有 $\pi $

    一定要记得分组！

    关于这里不细写了，看一看第一次作业的作业题推一遍应该就能会了。

## 关系演算

好像没讲，应该不考。

## 关系逻辑

好像没讲，应该不考

# 3 SQL语言

## SQL的组成

- 数据定义语言DDL：定义SQL模式、基本表、视图、索引。
- 数据操纵语言DML：数据查询和更新，更新包括插入、删除、修改。
- 嵌入式SQL语言的使用规定
- 数据控制语言DCL：对基本表和视图的授权，完整性规则的描述，事务控制

## DDL

- 模式创建：CREATE SCHEMA <模式名> AUTHORIZATION 用户名
- 模式撤销：DROP SCHEMA <模式名> [CASCADE | RESTRICT]
    - CASCADE：级联，SQL模式及其下属的基本表、视图、索引等所有元素全部撤销。
    - RESTRICT：约束，只有当SQL模式中没有任何下属元素时，才能撤销SQL模式，否则不执行SQL语句。

- 创建表：CREATE TABLE <基本表名>(<列名类型>,...,<完整性约束>,...)

    >CREATE TABLE C
    >
    >(
    >
    > CID CHAR(4),
    >
    >CNAME CHAR(10) NOT NULL,
    >
    >PRIMARY KEY(CID)
    >
    >FOREIGN KEY(TID) REFERENCES T(TID) *-- 注：外键和对应的引用的键可以不同名，指出对应性即可*
    >
    >)

- 添加列：ALTER TABLE <基本表名> ADD <列名><类型> *--注：不能定义为NOT NULL*

- 删除列：ALTER TABLE <基本表名> DROP <列名>[CASCADE | RESTRICT]

- 修改列的类型、宽度：ALTER TABLE <基本表名> MODIFY <列名><类型>

- 撤销表：DROP TABLE <基本表明> [CASCADE | RESTRICT]

- 创建索引：CREATE [UNIQUE] INDEX <索引名> ON <基本表名>(<列名序列>)

    - UNIQUE：每个索引值对应唯一的数据记录。

    - ASC升序，DESC降序，默认升序。

        >CREATE UNIQUE INDEX SC_INDEX ON SC(S# ASC, C# DESC)

- 撤销索引：DROP INDEX <索引名>

## DML

仅列一下关键字和基本用法供回忆，具体掌握还得实际去练。

> SELECT <目标表的列名或列表达式序列>
>
> FROM <基本表名或视图序列>
>
> [WHERE <行条件表达式>]
>
> [GROUP BY <列名序列>
>
> [HAVING <组条件表达式>]]
>
> [ORDER BY <列名[ASC|DESC]>,...]

- SELECT

    查询结果是一个表，可嵌套SELECT。可做并、交、差。(UNION,INTERSECT,EXCEPT)

- WHERE 字句的条件表达式F中可使用下列运算符：

    - <,<=,>,>=,=,<>或!=

    - AND,OR,NOT

    - IN,NOT IN
    - EXISTS,ALL,SOME,UNIQUE
        - 注意ALL和SOME是同义词，均表示左边的元组与右边的集合中至少一个元组满足运算。早期用ANY，后来改为SOME。

    - AVG,MIN,MAX,SUM,COUNT

    - SELECT语句嵌套

- EXISTS
- DISTINCT

- <表达式1> [NOT] BETWEEN <表达式2> AND <表达式3>

- <字符串> [NOT] LIKE <匹配模式> 

    - % 与0个或多个字符组成的字符串匹配。

        > where 姓名 LIKE '王%' 姓王的姓名

    - _ 与单个字符匹配

        > where 姓名 LIKE '王_' 姓王且全名为2个汉字的同学
        >
        > ’_丽%‘第二个字为丽

- <表达式> IS [NOT] NULL

- <元组> [NOT] IN (<集合>)

- [NOT] UNIQUE (<集合>) 判断集合是否有重复元组

    - 不存在重复元组，返回TRUE

- 外连接   [LEFT | RIGHT] JOIN <表名> ON (属性名1=属性名2)

- INSERT
    - INSERT INTO <基本表名> [(列名序列)] VALUES (<元组值>),(<元组值>)...(<元组值>)
    - INSERT INTO <基本表名> <SELECT 查询语句>
    - INSERT INTO <基本表名1> TABLE <基本表名2>

​		只有当属性个数、顺序和基本表的结构上完全一致，列名序列才可省略

- DELETE FROM <基本表名> WHERE <条件表达式>
- UPDATE <基本表名> SET <列名>=<值表达式>[,<列名>=<值表达式>...] | ROW=(<元组>) [WHERE <条件表达式>]

- CREATE VIEW <视图名>（<列名序列>） AS <SELECT 查询语句>
    - 允许用户更新的视图，在定义时必须加上“WITH CHECK OPTION”
    - 定义在多个基本表上的视图，或者用聚合操作的视图，或不包含基本表主键的视图，不允许更新。

- DROP VIEW <视图名>

# 4 关系数据库的规范化设计

一个关系模式包括**外延**和**内涵**两方面的内容。

- 外延：关系、表或当前值。外延与时间有关。
- 内涵（**关系模式**）：与时间独立，是对数据的定义以及数据完整性约束的定义。
    - 对数据的定义：对关系、属性、域的定义和说明
    - 对数据完整性约束的定义：
        - 静态约束：涉及数据之间的联系（**函数依赖**），主键和值域的设计
        - 动态约束：定义各种操作（插入、删除、修改）对关系值的影响。

## 关系模式的冗余和异常问题

模式可能出现的问题：

数据冗余：在关系中要出现多个元组，某些属性要重复多次

操作异常：由于数组冗余，在对数据进行操作时会引起各种异常。

- 修改异常：一个改了，而其他相同的没改
- 插入异常：主键出现空值
- 删除异常：如果要删除选课，则教师也要删除，这不合适。

## 关系模式的非形式化设计准则

- 尽可能只包含有直接联系的属性，不要包含有间接联系的属性。
- 尽可能使得相应关系中不出现插入、删除和修改等操作异常现象。
- 尽可能使得相应关系中避免放置经常为空值的属性。
- 尽可能使得关系的等值连接在主键和外键的属性上进行，并且保证连接以后不会生成额外的元组。（**无损分解**）

## 函数依赖

函数依赖（FD）是最基本、最重要的一种依赖。是关键码概念的推广。

> 对于关系r的任意两个元组，如果X值相同，则要求Y值也相同。即，有一个X值就有一个Y值与之对应，或者说Y值由X值决定。这种依赖称为函数依赖。

$X \rightarrow Y$​：Y函数依赖于X，X函数决定Y

### 逻辑蕴含

若从函数依赖的集合$F$能推出一个函数依赖$X \rightarrow Y$，则称$F 逻辑蕴含 X \rightarrow Y$：

$F \models X \rightarrow Y$

### FD的推理规则

Armstrong公理：

- 自反性：$若Y \subseteq X \subseteq U ，则X \rightarrow Y在R上成立$

- 增广性：$若X \rightarrow Y 在 R上成立，且Z \subseteq U，则XZ \rightarrow YZ 在R上成立$
- 传递性：$若 X\rightarrow Y 和 Y\rightarrow Z在R上成立，则X\rightarrow Z 在R上成立$

- 合并性：$\{X \rightarrow Y,X \rightarrow Z\} \models X\rightarrow YZ $
- 分解性：$\{X \rightarrow Y, Z \subseteq Y\} \models X \rightarrow Z$
- 伪传递性：$\{X \rightarrow Y, WY\rightarrow Z\} \models WX \rightarrow Z$
- 复合性：$\{X \rightarrow Y,W\rightarrow Z\} \models XW \rightarrow YZ$
- 通用一致性定理：$\{X \rightarrow Y,W \rightarrow Z\}\models X \cup(W-Y)\rightarrow YZ  $

### 闭包

通过推理规则，求出所有可能的函数依赖。求闭包是一个NP完全问题，指数级时间问题。

$F^+ = \{X \rightarrow Y | F \models X \rightarrow Y \}$

### 关键码

如果$X \rightarrow U$ 在 $R$ 上成立，则$X$是$R$的一个超键。如果$X$是能找到的最小的超键，则$X$是$R$上的一个候选键。

**候选键可能有多个**

- 找到只在左边、右边和左右都出现的属性。只左必定是候选键的一部分，只右一定不是候选键的一部分。
- 只左与左右的元素组合，推函数依赖，看其闭包是否为属性全集

### 推理规则的完备性

从FD集F使用推理规则集推出的FD必定在$F^+$中。

### 求最小函数依赖集$F_{min}$

最小函数依赖集G：

- G的每个FD的右边都是单属性。

- G中没有冗余的FD。

    即G中不存在这样的函数依赖$X \rightarrow Y$，使得$G - \{X\rightarrow Y\}$ 与G等价

- G中每个FD的左边没有冗余的属性。

    即G中不存在这样的函数依赖$X \rightarrow Y$，对于$X$的真子集$W$，使得$G - \{X\rightarrow Y\} \cup \{W \rightarrow Y\}$​​ 与G等价。

- 不唯一

步骤：

- 做右侧拆分，$X \rightarrow AB $拆成$X \rightarrow A,X \rightarrow B $
- 做左侧拆分，判断$AB \rightarrow X$是否可以用$A \rightarrow X$或者$B \rightarrow X$来取代。
- 逐一检查各剩下的函数依赖是否可以从其他函数依赖推出：逐个删除函数依赖，求剩下的函数依赖集从被删除函数依赖左侧开始的闭包。若闭包中包含了被删除的函数依赖的右侧属性，则可以删除该冗余函数依赖。

例：$设F = \{A \rightarrow BC,AD\rightarrow E , B \rightarrow E,E \rightarrow G,B \rightarrow G\}\\$​

1. 右侧拆分

​	$F = \{A \rightarrow B ,A \rightarrow C,AD \rightarrow E,B \rightarrow E,E \rightarrow G,B \rightarrow G \}$

2. 左侧拆分

    $F = \{A \rightarrow B ,A \rightarrow C,A \rightarrow E,D \rightarrow E,B \rightarrow E,E \rightarrow G,B \rightarrow G \}$

3. 逐一检查各剩下的函数依赖是否可以从其他函数依赖推出
    $$
    3.1 删除A \rightarrow B，B \notin A^+=\{ ACEG \}，所以A \rightarrow B 不可删除 \\
    	3.2 删除A \rightarrow C，C \notin A^+=\{ ABEG \}，所以A \rightarrow C 不可删除 \\
    	3.3 删除A \rightarrow E，E \in A^+=\{ ABCEG \}，所以A \rightarrow E 可以删除 \\
    	3.4 删除B \rightarrow E，E \notin B^+=\{ BG \}，所以B \rightarrow E 不可删除 \\
    	3.5 删除E \rightarrow G，G \notin E^+=\{ E \}，所以E \rightarrow G 不可删除 \\
    	3.6 删除B \rightarrow G，G \in B^+=\{ EG \}，所以B \rightarrow G 可以删除
    $$

## 模式分解

设有关系模式$R(U)$，属性集为$U,R_1,R_2,...,R_k$都是$U$的子集。且$R_1 \cup R_2 \cup ... \cup R_k = U$。关系模式$R_1,...,R_k$的集合用$\rho$表示，$\rho = \{R_1,...,R_k\}$用$\rho$代替$R$的过程，称为关系模式的分解。$\rho$称为$R$​的一个分解。

### 无损分解

分解后的关系做自然连接，连接的结果不变

优点：

- 消除数据冗余的操作异常现象
- 可以存储悬挂元组，存储泛关系中无法存储的信息

缺点：

- 分解以后，检索操作需要做笛卡尔积或连接操作，付出时间代价
- 可能产生寄生元组，损失了信息。

#### 是否为无损分解

- chase方法（不考）

- $U_1 \cap U_2 \rightarrow (U_1 - U_2) | (U_2 - U_1)$​ 若成立，则为无损分解。

- 例：
    $$
    已知：R<U,F>,U=\{A,B,C\}\\F = \{A \rightarrow B\},\rho_1 = \{R_1(AB),R_2(AC)\} \\
    解：
    U_1\cap U_2 = A,U_1 - U_2 = B \\
    \because A \rightarrow B \\
    \therefore U_1 \cap U_2 \rightarrow U_1-U_2 \\
    \therefore \rho_1是无损连接分解
    $$

### 保持函数依赖

- 如果不能保持FD，那么**数据的语义就会出现混乱**

- **保持函数依赖和无损分解之间没有任何必然联系**

#### 是否保持函数依赖

分解的各个函数依赖集的并等价于原F
$$
设R(A,B,C,D),F = \{A\rightarrow B,C\rightarrow D\} \\
\rho = \{R_1(A,B),R_2(C,D)\} \\
\Pi_{R_1}(F) = \{A\rightarrow B\} \\
\Pi_{R_2}(F) = \{C\rightarrow D\} \\ 
\Pi_{R_1}(F) \cup \Pi_{R_2}(F) 等价于F，因此分解\rho保持函数依赖
$$

## 关系模式的范式

### 1NF

每个关系r的属性值都是不可分的原子值

### 2NF

在1NF的基础上，每个非主属性完全函数依赖于候选键。

- 主属性：包含在任何一个候选码中的任何一个属性。

- 完全函数依赖：左部不可约依赖。

    > 对于FD $W \rightarrow A$，如果存在$X \subset W$ 有 $X \rightarrow A$成立，那么称$W \rightarrow A$是局部函数依赖。否则，称为完全函数依赖。

### 3NF

在2NF的基础上，每个非主属性都不传递依赖于R的候选键。

> 如果$X \rightarrow Y,Y\rightarrow A,且Y \nrightarrow X和A \notin Y$，那么称$X \rightarrow A$是传递依赖。

### BCNF

在3NF的基础上，每个属性都不传递依赖于R的候选键。

任何一个关系模式都能**无损连接地**分解成BCNF的集合。注意：不一定保持函数依赖

| 范式 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 1    | 每个属性不可再分                                             |
| 2    | 消除非主属性对键的部分依赖                                   |
| 3    | 消除非主属性对键的传递依赖                                   |
| BC   | 如果在关系R中，U为主键，A属性是主键的一个属性，<br />若存在A->Y，Y为主属性，则该关系不属于BCNF |

### 分解成3NF的算法

**任何一个关系模式都可无损连接且保持函数依赖地分解成3NF的集合。**

1. 求R的候选键，并计算F的最小函数依赖集，然后将左边相同的FD合并
2. 对$F_{min}$中的每一个FD $X \rightarrow Y$，构造一个模式XY，形成模式集
3. 如果现有模式集中的每个模式都不包含原关系R的候选键，则选一个候选键构造一个关系模式，放入模式集，然后输出。否则，直接输出。

- 例：
    $$
    R<U,F>,U=\{A,B,C,D\},F=\{A\rightarrow B,B\rightarrow C,AB\rightarrow D\}
    $$

    1. 求R的候选键，并计算F的最小函数依赖集，然后将左边相同的FD合并

        1. 求R的候选键
            $$
            只出现在左边：A \\
            左右都出现：B \\
            只出现在右边：C,D\\ 
            A^+ = \{ABCD\} = U \\
            \therefore R的候选键为A
            $$

        2. 计算$F_{min}$

            1. 右侧拆分（无）

            2. 左侧拆分
                $$
                F = \{A\rightarrow B,B\rightarrow C,A\rightarrow D\,B\rightarrow D\}
                $$

            3. 逐一检查各剩下的函数依赖是否可以从其他函数依赖推出
                $$
                3.1 删除A \rightarrow B，B \notin A^+=\{ AD \}，所以A \rightarrow B 不可删除 \\
                	3.2 删除B \rightarrow C，C \notin B^+=\{ BD \}，所以B \rightarrow C 不可删除 \\
                	3.3 删除A \rightarrow D，E \in A^+=\{ ABCD \}，所以A \rightarrow D 可以删除 \\
                	3.4 删除B \rightarrow D，D \notin B^+=\{ BC \}，所以B \rightarrow D 不可删除 \\
                $$

            4. 
                $$
                F_{min} =\{A\rightarrow B,B\rightarrow C,B\rightarrow D\}
                $$

        3. 将左边相同的FD合并

            $F = {A\rightarrow B,B\rightarrow CD}$

    		2. 对$F_{min}$中的每一个FD $X \rightarrow Y$，构造一个模式XY，形成模式集

         $R_1(AB),R_2(BCD)$

    		3. 由于$R_1$包含了候选键$A$，所以$\rho=\{R_1(AB),R_2(BCD)\}$就是一个满足条件的分解。