# 2 处理器管理

处理器管理负责**管理、调度和分配计算机系统的处理器资源**，并控制程序的执行。

无论在应用程序，还是系统程序，最终都要在处理器上执行以实现其功能。处理器管理的优劣将直接影响到计算机系统的性能。

## 程序状态字寄存器

程序状态字PSW：指示处理器状态、控制指令的执行顺序、保留和指示与运行程序相关的各种信息。主要作用是方便实现程序状态的保护与恢复。每一个程序都有一个与其执行相关的PSW，每个处理器都设置一个程序状态寄存器。一个程序占有处理器执行时，它的PSW将占有程序状态字寄存器。

PSW包括：程序计数器、指令寄存器、条形码、中断位、中断允许位、中断屏蔽位、处理器模式位、主存保护位等，记录当前程序的动态信息。

## 操作系统的运行机制

### 特权指令与非特权指令

- 特权指令：可能涉及到改变处理器状态等的敏感操作。如内存清零。权限高，不允许用户程序使用。
- 非特权指令：如普通的运算指令，加减乘除，权限低。

### 用户态与内核态

- 用户态（目态）：只能执行非特权指令
- 内核态（管态）：能执行特权指令和非特权指令

两种处理器状态存储在在PSW中的处理器模式位。

### 内核程序与应用程序

- 操作系统内核程序：特权高，可使用全部机器指令
- 运行于OS环境的普通应用程序：权限低，只能使用资源管理命令之外的指令

### 宏内核与微内核

- 宏内核：资源管理+支撑功能。*LINUX,UNIX*

- 微内核：支撑功能。*Windows NT*

    操作系统内核需要运行在内核态，操作系统的非内核功能运行在用户态。

### 处理器状态转换

- 内核态->用户态

    执行一条特权指令——修改PSW的标志位为”用户态“。操作系统将主动让出CPU使用权。

- 用户态->内核态

    由”中断“引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。

    **只有中断才能使处理器从用户态向内核态转换**。*例如：程序主动同步请求OS服务，执行系统调用*

## 中断

中断是多道程序得以实现以及设备管理的基础。

中断处理程序是I/O系统最底层，是整个I/O系统的基础。

只要发生中断，就意味着OS介入，参加管理工作。

### 中断的类型

- 内中断（陷入、trap）：由CPU内部事件所引起的中断。
    - 硬件故障中断事件：电源故障、主存故障：保护现场、停止工作、估计恢复
    - 程序性中断事件：算数异常、指令异常、终止进程指令、虚拟地址异常：报告用户、终止进程、重新执行指令。
    - 自愿性中断：系统调用：陷入指令->执行系统调用服务例程。

- 外中断：CPU对I/O设备发来的中断信号的一种响应。
    - I/O中断事件
    - 外部中断事件：时钟、间隔时钟、设备、键鼠信号、关机重启等

## 系统调用

程序接口由一组系统调用组成。

发出系统调用请求的在用户态，对系统调用的相应处理在内核态。

陷入指令（trap指令/访管指令）是唯一一个只能在用户态下执行，不在内核态执行的指令。

凡是与共享资源有关的操作，会直接影响到其他进程的操作，就一定需要操作系统介入，就需要通过系统调用来实现。

## 进程管理

### 进程的概念

- 程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。由程序段和数据两部分组成。

    进程是程序在处理机上的一次执行过程，是一个动态的概念。由程序段、数据和PCB组成。

- 同一程序可以对应多个进程，进程更能真实地描述并发，而程序不能
- 进程具有创建其他进程的功能，而程序没有
- 进程是动态的，而进程实体（进程映像）是静态的。进程实体反映了进程在某一时刻的状态。
- 进程与PCB一一对应，PCB是系统感知进程存在的唯一标志。

### PCB

#### PCB的作用

- 作为独立运行基本单位的标志
- 能实现间断性运行方式
- 提供进程管理所需要的信息
- 提供进程调度所需要的信息
- 实现与其他进程的同步和通信

#### PCB中的信息

- 进程描述信息
    - 进程标识符，唯一，通常是一个整数
    - 进程名，通常基于可执行文件名
    - 用户标识符
- 进程控制和管理信息
    - 当前状态
    - 优先级
    - 代码执行入口地址
    - 程序的外存地址
    - 运行统计信息（执行时间、页面调度）
    - 进程间同步和通信；阻塞原因
    - 进程的队列指针
    - 进程的消息队列指针
- 资源分配清单（资源使用情况）
    - 虚拟地址空间的现状
    - 打开文件列表
- 处理器相关信息（CPU现场保护信息）
    - 寄存器值（通用、程序计数器PC、状态PSW、地址包括栈指针）
    - 指向赋予该进程的段/页表的指针

#### PCB的组织形式

系统将所有PCB组织在一起，并把它们放在内存的固定区域，构成了PCB表。

**PCB表的大小**决定了系统中最多可同时存在的进程个数，称为系统的**并发度**。

- 链接方式

    相同状态的进程PCB组成一个链表，不同状态对应多个不同的链表。

- 索引方式

    相同状态的进程，分别设置各自的PCB索引表，表明PCB在PCB表中的地址。

### 进程的特征

- 动态性：进程是程序的执行
- 并发性：多个进程可同存于内存中，能在一段时间内同时运行
- 独立性：独立运行的基本单位，独立获得资源和调度的基本单位
- 异步性：各进程按各自独立的不可预知的速度向前推进
- 结构性：每个进程都配置一个PCB，进程由程序段、数据段和PCB组成

### 进程的状态

#### 创建

进程正在被创建，操作系统为进程分配资源、初始化PCB

- 一般步骤：
    - 申请一个空白PCB，在PCB中填写用于控制和管理进程的信息
    - 分配资源
    - 设置为就绪状态并插入就绪队列中
- 目的：
    - 保证进程的调度在创建通过完成后进行，以确保对进程控制的完整性
    - 增加管理的灵活性
- 允许一个进程创建另一个进程。
    - 进程图：描述进程间关系的一棵有向树。
    - 引起创建进程的四类典型事件：
        - 用户登录
        - 作业调度
        - 提供服务
        - 应用请求

#### 运行

正在运行的进程所处的状态，拥有CPU

#### 就绪

存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行。

#### 阻塞

若一进程正在等待某一事件发生（如等待I/O），这时，即使给它CPU，它也无法运行。（阻塞/等待/睡眠/封锁状态）。

当一个进程所期待的某一时间尚未出现时，该进程调用阻塞原语将自己阻塞。进程阻塞是进程的自身的一种主动行为。

#### 终止

进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

- 一般步骤
    - 等待操作系统进行善后处理
    - 将PCB清零，将PCB空间返还系统
- 终止原因
    - 正常结束
    - 异常结束：越界错、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障
    - 外界干预：操作员或操作系统干预、父进程请求、因父进程终止

- 终止过程

    - 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB

    - 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度

    - 若该进程还有子孙进程，还应将其所有子孙也都予以终止，以防它们成为不可控的进程

    - 将进程所拥有的资源交给父进程或系统进程

    - 释放PCB

---

### 进程的操作

#### 挂起

将内存中的一部分进程转移到磁盘中。

当内存中所有进程阻塞时，操作系统可将一进程置为挂起状态并交换到磁盘，再调入另一进程执行。

- 活动就绪（Readya）：未被挂起的就绪状态。此时的进程可以接受调度。处于Readys状态的进程用激活原语Active激活后，进程转变为Readya。
- 静止就绪（Readys）：用suspend原语将活动就绪挂起后，变为静止就绪。
- 活动阻塞（Blockeda）：未被挂起的阻塞状态。处于Blockeds状态的进程用激活原语激活后，进程变为Blockeda。
- 静止阻塞（Blockeds）：用suspend原语将活动阻塞挂起后，变为静止阻塞。

#### 激活

active;静止就绪->活动就绪；静止阻塞->活动阻塞。

#### 唤醒

阻塞的进程，由它的合作进程用唤醒原语唤醒它。





![5个状态模型](./2%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20240518222229269.png)

![image-20240518222652904](./2%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20240518222652904.png)

- 



![image-20240518223034712](./2%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20240518223034712.png)

![image-20240518223136222](./2%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20240518223136222.png)

注：上图应该是执行->活动阻塞，原图箭头不对。

![image-20240518231826575](./2%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20240518231826575.png)

### 原语及其原子性

执行关中断指令，不再检查中断信号，直到执行开中断指令后才恢复检查。

### 进程通信

指进程之间的信息交换。

- 共享存储
    - 互斥访问，操作系统只负责提供共享空间和同步互斥工具（P\V操作）
    - 基于数据结构的共享：共享空间里放一个长度为10的数组。速度慢、限制多、是一种低级通信方式。
    - 基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。速度更快，是高级通信方式。
- 信息传递
    - 以格式化的消息为单位，通过操作系统提供的”发送消息/接收消息“两个原语进行数据交换。
    - 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
    - 间接通信方式：消息先发送到中间实体（信箱）中
- 管道通信
    - 管道是用于连接读写进程的一个共享文件，又名pipe文件。是再内存中开辟一个大小固定的缓冲区。
    - 管道只能采用半双工通信，某一个时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
    - 各进程要互斥地访问管道。
    - 数据以字符流的方式写入管道，当管道写满时，写进程将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，读进程被阻塞。
    - 如果没写满，就不允许读；如果没读空，就不允许写。
    - 数据一旦被读出，就从管道中抛弃，这意味着读进程最多只能有一个，否则可能会有读错数据的情况。

- 客户机/服务器系统
