- 算法由有限条指令构成，每条指令规定了计算机所要执行的有限次运算或者操作。
- “有着本质改进的高效算法”：算法的时间复杂度由指数函数降为多项式函数。

# 时间复杂度

- 最坏情况下的时间复杂度$W(n)$

- 平均情况下的时间复杂度$A(n)$​

    给出规模为$n$的所有输入实例的概率分布。

    假定实例集合为$S$，实例$I \in S$出现的概率为$p_i$，算法对于$I$所做的基本运算次数为$t_I$，那么平均情况下的时间复杂度为$\sum\limits_{i=1}t_Ip_I$。

>   例：顺序检索
>
>   假定检索值$x$在$L$中的概率为$p$，且处在$L$每个位置的概率相等。
>
>   $A(n) = \sum\limits_{i=1}^n i \frac{p}{n} + (1-p)n$ 

# 算法的伪码描述

-   赋值 $\leftarrow$
-   分支 $if \cdots then \cdots [else \cdots]$
-   循环 while,for,repeat until
-   转向：goto
-   输出：return
-   调用：.
-   注释：$//\cdots$

# 算法的数学基础

## 函数的渐近的界

### 基本概念

$\exist n_0 > 0,\forall n \geq n_0$的实际含义是，数据输入达到了一定的规模。

-   $若\exist c>0,n_0>0,使得\forall n\geq n_0,有0 \leq f(n) \leq cg(n) 成立，则称f(n)的渐近的上界是g(n),记作f(n) = O(g(n))$

    >   对于函数$g(n)$，**仅需**乘上一个常数$c$就可以让它不严格地大于$f(n)$，则$g(n)$是$f(n)$的渐近的上界。这意味着$f(n)$的阶可能等于$g(n)$的阶，也可能小于$g(n)$的阶。

-   $若\exist c>0,n_0>0,使得\forall n\geq n_0,有0 \leq cg(n) \leq f(n) 成立，则称f(n)的渐近的下界是g(n),记作f(n) = \Omega(g(n))$

    >   对于函数$g(n)$，**即使**乘上一个常数$c$，也还是会不严格地小于$f(n)$，则$g(n)$是$f(n)$的渐近的下界。这意味着$f(n)$的阶只可能小于$g(n)$的阶。

-   $若\forall c>0, \exist n_0,使得当n \geq n_0 时有0 \leq f(n) <cg(n)成立，则称f(n)的非紧上界是g(n),记作f(n) = o(g(n))$

    >   对于函数$g(n)$，**即使**乘上任意一个**可以非常非常小**的数$c$，也还是会严格地大于$f(n)$，则$g(n)$是$f(n)$的非紧上界。

-   $若\forall c>0, \exist n_0,使得当n \geq n_0 时有0 \leq cg(n) < f(n)成立，则称f(n)的非紧下界是g(n),记作f(n) = \omega(g(n))$

    >   对于函数$g(n)$，**即使**乘上任意一个**可以非常非常大**的数$c$，也还是会严格地小于$f(n)$，则$g(n)$是$f(n)$的非紧下界。

-   $若f（n） = O(g(n)) 且 f(n) = \Omega(g(n)),则称f(n)的渐近紧界是g(n),记作f(n) = \Theta(g(n))$​

    >   例：
    >
    >   对于函数$f(n) = n^2 + n$
    >
    >   可以写为：$f(n) = O(n^2),f(n) = O(n^3),f(n) = o(n^3)$
    >
    >   但是不能写为$f(n) = o(n^2)$

### 相关定理

-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)}存在且值等于某个常数c>0,那么f(n) = \Theta(g(n))$
-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)} = 0,那么f(n) = o(g(n))$
-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)} = +\infty,那么f(n) = \omega(g(n))$​
-   $如果f = O(h),g = O(h),那么f+g = O(h)$​
-   $f = \Theta(f)$
-   $如果g= O(f),那么f+g = \Theta(f)$

### 相关性质

-   $如果f=O(g),g=O(h),那么f=O(h)$

-   $如果f=\Omega(g),g=\Omega(h),那么f=\Omega(h)$

-   $如果f=\Theta(g),g=\Theta(h),那么f=\Theta(h)$​

-   有些函数中的$n$​虽然表面上看处在指数位置，但仍有可能是多项式函数。

    >   $a^{\log_bn} = n^{\log_ba}$ ，只要对等式两边取以$b$为底的对数，都会得到$\log_ba\cdot\log_bn$

-   对于不同的底数，指数函数的阶是不相同的。底越大，指数函数的阶就越高。
-   $n! = o(n^n),n! = \omega(2^n),\log(n!) = \Theta(n\log n)$​

# 关于几类函数的阶的结果

-   多项式函数$f(n) = a_0+a_1n+a_2n^2+\cdots+a_dn^d$，有$f(n) = \Theta(n^d)$
-   对数函数对于每个$b>1$和每个$a>0$，有$\log_bn=o(n^a)$；对于不同的$a$与$b$，$a,b>1$，$\log_an=\Theta(\log_bn)$
-   指数函数：对于每个$r>1$和每个$d>0$，$r^n$满足$n^d=o(r^n)$
-   阶乘函数：斯特灵公式$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n}))$

# 求和的方法

$$
\sum\limits_{k=1}^n a_k = \frac{(a_1+a_n)n}{2} \\
\sum\limits_{k=0}^n aq^k = \frac{a(1-q^{n+1})}{1-q}\\
\sum\limits_{k=1}^n \frac{1}{k} = \log n+O(1)
$$

## 放大方法

假设存在常数$r<1$，使得$\frac{a_{k+1}}{a_k}\leq r$对一切$k \geq 0$成立，那么有
$$
\sum\limits_{k=0}^n a_k \leq \sum\limits_{k=0}^\infty a_0r^k = a_0\sum\limits_{k=0}^\infty r^k = \frac{a_0}{1-r}
$$

# 递归方程求解方法

## 迭代法

>   例：
>   $$
>   \left\{ 
>   \begin{aligned}
>   W(n) & = &  W(n-1) + n - 1 \\
>   W(1) & = & 0
>   \end{aligned}
>   \right.
>   $$
>   解：
>   $$
>   \begin{align}
>   W(n) & =  W(n-1) + n-1 \\
>   & =  [W(n-2)+n-1] + n-1 = W(n-2)+(n-2)+(n-1) \\
>   & =  W(n-3) + (n-3) + (n-2) + (n-1) \\
>   & =  \cdots \\
>   & =  W(1) + 1 + 2 + \cdots + (n-1) \\
>   & =  0+1+2+\cdots+(n-1) \\
>   & = \frac{n(n-1)}{2} 
>   \end{align}
>   $$
>   归纳验证：
>
>   当$n=1$时，$W(1) = 0$符合给定的初值。
>
>   假设对于$n$，有$W(n) = \frac{(n-1)n}{2}$，那么
>
>   $W(n+1) = W(n) + n = \frac{n(n+1)}{2}$
>
>   从而证明了$W(n) = \frac{n(n-1)}{2}$​是原递推方程的解。

## 差消法

**全部历史递推方程**：$T(n)$依赖于$T(n-1),T(n-2),\cdots,T(1),T(0)等所有的项$

>   例：
>
>   求解下述递推方程：
>   $$
>   \left\{
>   \begin{align}
>   T(n) &= \frac{2}{n}\sum\limits_{i=1}^{n-1}T(i) + n-1 \\
>   T(1) &= 0
>   \end{align}
>   \right.
>   $$
>   由原方程等到
>
>   $nT(n) = 2\sum\limits_{i=1}^{n-1}T(i) + n^2-n$
>
>   $(n-1)T(n-1) = 2\sum\limits_{i=1}^{n-2}T(i) + (n-1)^2-(n-1)$
>
>   将两个方程相减，得到
>
>   $nT(n) - (n-1)T(n-1) = 2T(n-1)+2n-2$
>
>   化简得到
>
>   $nT(n) = (n+1)T(n-1) + 2n - 2$
>
>   变形
>
>   $\frac{T(n)}{n+1} = \frac{T(n-1)}{n} + \frac{2n-2}{n(n+1)} = $
>
>   迭代得到
>
>   $\frac{T(n)}{n+1} = 2(\frac{1}{n+1} + \frac{1}{n} + \cdots + \frac{1}{3}) + \frac{T(1)}{2} -1 + O(\frac{1}{n})$
>
>   括号内为调和级数之和，$\Theta(\log n)$
>
>   因此原递推方程的解为$T(n) = \Theta(n\log n)$

## 递归树

递归树是一棵结点带权的二叉树。根节点权为$W(n)$，不断迭代直到树中不再含有**权为函数**的结点为止。迭代规则就是将递归树中权为函数的结点，如$W(n),W(\frac{n}{2})$​，用**和这个函数相等的递推方程右部的**子树来代替。

以
$$
\left\{
\begin{align}
W(n) &= 2W(n/2) + n - 1,n = 2^k \\
W(1) &= 0
\end{align}
\right.
$$
为例：

![image-20240521133001843](./1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.assets/image-20240521133001843.png)

整个迭代过程中，递归树中全部结点的**权之和不变**。

分层计算，上例中递归树有$k$层，各层结点的值之和分别为

$n-1,n-2,n-4,\cdots,n-2^{k-1}$

所以$W(n) = kn + \sum\limits_{i=1}^k2^{i-1} = n\log n - n + 1$

## 主定理

$设a \geq 1,b >1为常数，f(n) 为函数，T(n)为非负整数，且T(n) = aT(n/b) + f(n),则 $
$$
\begin{align}
若f(n) & = O(n^{\log_ba-\epsilon}),\epsilon>0,那么T(n) = \Theta(n^{\log_ba}) \\
若f(n) & = \Theta(n^{\log_ba}),那么T(n) = \Theta(n^{\log_ba}\log n) \\
若f(n) & = \Omega(n^{\log_ba+\epsilon}),\epsilon>0,且对于某个常数c<1和所有充分大的n，有af(n/b)\leq cf(n)，那么\\T(n) &= \Theta (f(n))
\end{align}
$$

$a代表递归调用所产生的子问题个数，n/b代表这些子问题的规模，f(n)代表调用前的操作及调用后把子问题的解组合成原问题的解的工作量。$

# 习题

1.3

1.5

1.7

1.8

1.13

1.19.5

1.19.6

1.21

# 补充

$2^{2^n}\rightarrow \log(2^{2^n}) = 2^n\log2$

$n! \rightarrow \log(n!) = n\log n$

$\therefore 2^{2^n} > n!$​

---

$(\log n)^{\log n} = n ^{\log \log n}$

$n = \Theta(2^{\log n})$

$n ^ {1/\log n} = \Theta(1)$

---

$\sum\limits_{i=1}^{n}i^2 = \frac{n(n+1)(2n+1)}{6}$

