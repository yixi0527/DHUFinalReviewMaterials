# 1 基础知识

- 算法由有限条指令构成，每条指令规定了计算机所要执行的有限次运算或者操作。
- “有着本质改进的高效算法”：算法的时间复杂度由指数函数降为多项式函数。

## 时间复杂度

- 最坏情况下的时间复杂度$W(n)$

- 平均情况下的时间复杂度$A(n)$​

    给出规模为$n$的所有输入实例的概率分布。

    假定实例集合为$S$，实例$I \in S$出现的概率为$p_i$，算法对于$I$所做的基本运算次数为$t_I$，那么平均情况下的时间复杂度为$\sum\limits_{i=1}t_Ip_I$。

>   例：顺序检索
>
>   假定检索值$x$在$L$中的概率为$p$，且处在$L$每个位置的概率相等。
>
>   $A(n) = \sum\limits_{i=1}^n i \frac{p}{n} + (1-p)n$ 

## 算法的伪码描述

-   赋值 $\leftarrow$
-   分支 $if \cdots then \cdots [else \cdots]$
-   循环 while,for,repeat until
-   转向：goto
-   输出：return
-   调用：.
-   注释：$//\cdots$

## 算法的数学基础

### 函数的渐近的界

#### 基本概念

$\exist n_0 > 0,\forall n \geq n_0$的实际含义是，数据输入达到了一定的规模。

-   $若\exist c>0,n_0>0,使得\forall n\geq n_0,有0 \leq f(n) \leq cg(n) 成立，则称f(n)的渐近的上界是g(n),记作f(n) = O(g(n))$

    >   对于函数$g(n)$，**仅需**乘上一个常数$c$就可以让它不严格地大于$f(n)$，则$g(n)$是$f(n)$的渐近的上界。这意味着$f(n)$的阶可能等于$g(n)$的阶，也可能小于$g(n)$的阶。

-   $若\exist c>0,n_0>0,使得\forall n\geq n_0,有0 \leq cg(n) \leq f(n) 成立，则称f(n)的渐近的下界是g(n),记作f(n) = \Omega(g(n))$

    >   对于函数$g(n)$，**即使**乘上一个常数$c$，也还是会不严格地小于$f(n)$，则$g(n)$是$f(n)$的渐近的下界。这意味着$f(n)$的阶只可能小于$g(n)$的阶。

-   $若\forall c>0, \exist n_0,使得当n \geq n_0 时有0 \leq f(n) <cg(n)成立，则称f(n)的非紧上界是g(n),记作f(n) = o(g(n))$

    >   对于函数$g(n)$，**即使**乘上任意一个**可以非常非常小**的数$c$，也还是会严格地大于$f(n)$，则$g(n)$是$f(n)$的非紧上界。

-   $若\forall c>0, \exist n_0,使得当n \geq n_0 时有0 \leq cg(n) < f(n)成立，则称f(n)的非紧下界是g(n),记作f(n) = \omega(g(n))$

    >   对于函数$g(n)$，**即使**乘上任意一个**可以非常非常大**的数$c$，也还是会严格地小于$f(n)$，则$g(n)$是$f(n)$的非紧下界。

-   $若f（n） = O(g(n)) 且 f(n) = \Omega(g(n)),则称f(n)的渐近紧界是g(n),记作f(n) = \Theta(g(n))$​

    >   例：
    >
    >   对于函数$f(n) = n^2 + n$
    >
    >   可以写为：$f(n) = O(n^2),f(n) = O(n^3),f(n) = o(n^3)$
    >
    >   但是不能写为$f(n) = o(n^2)$

#### 相关定理

-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)}存在且值等于某个常数c>0,那么f(n) = \Theta(g(n))$
-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)} = 0,那么f(n) = o(g(n))$
-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)} = +\infty,那么f(n) = \omega(g(n))$​
-   $如果f = O(h),g = O(h),那么f+g = O(h)$​
-   $f = \Theta(f)$
-   $如果g= O(f),那么f+g = \Theta(f)$

#### 相关性质

-   $如果f=O(g),g=O(h),那么f=O(h)$

-   $如果f=\Omega(g),g=\Omega(h),那么f=\Omega(h)$

-   $如果f=\Theta(g),g=\Theta(h),那么f=\Theta(h)$​

-   有些函数中的$n$虽然表面上看处在指数位置，但仍有可能是多项式函数。


>   $a^{\log_bn} = n^{\log_ba}$ ，只要对等式两边取以$b$为底的对数，都会得到$\log_ba\cdot\log_bn$

-   对于不同的底数，指数函数的阶是不相同的。底越大，指数函数的阶就越高。
-   $n! = o(n^n),n! = \omega(2^n),\log(n!) = \Theta(n\log n)$​

### 求和的方法

$$
\sum\limits_{k=1}^n a_k = \frac{(a_1+a_n)n}{2} \\
\sum\limits_{k=0}^n aq^k = \frac{a(1-q^{n+1})}{1-q}\\
\sum\limits_{k=1}^n \frac{1}{k} = \ln n+O(1)
$$

#### 放大方法

假设存在常数$r<1$，使得$\frac{a_{k+1}}{a_k}\leq r$对一切$k \geq 0$成立，那么有
$$
\sum\limits_{k=0}^n a_k \leq \sum\limits_{k=0}^\infty a_0r^k = a_0\sum\limits_{k=0}^\infty r^k = \frac{a_0}{1-r}
$$

## 递归方程求解方法

### 迭代法

>   例：
>   $$
>   \left\{ 
>   \begin{aligned}
>   W(n) & = &  W(n-1) + n - 1 \\
>   W(1) & = & 0
>   \end{aligned}
>   \right.
>   $$
>   解：
>   $$
>   \begin{align}
>   W(n) & =  W(n-1) + n-1 \\
>   & =  [W(n-2)+n-1] + n-1 = W(n-2)+(n-2)+(n-1) \\
>   & =  W(n-3) + (n-3) + (n-2) + (n-1) \\
>   & =  \cdots \\
>   & =  W(1) + 1 + 2 + \cdots + (n-1) \\
>   & =  0+1+2+\cdots+(n-1) \\
>    & = \frac{n(n-1)}{2} 
>   \end{align}
>   $$
>   归纳验证：
>
>   当$n=1$时，$W(1) = 0$符合给定的初值。
>
>   假设对于$n$，有$W(n) = \frac{(n-1)n}{2}$，那么
>
>   $W(n+1) = W(n) + n = \frac{n(n+1)}{2}$
>
>   从而证明了$W(n) = \frac{n(n-1)}{2}$​是原递推方程的解。

### 差消法

**全部历史递推方程**：$T(n)$依赖于$T(n-1),T(n-2),\cdots,T(1),T(0)等所有的项$

>   例：
>
>   求解下述递推方程：
>   $$
>   \left\{
>   \begin{align}
>   T(n) &= \frac{2}{n}\sum\limits_{i=1}^{n-1}T(i) + n-1 \\
>   T(1) &= 0
>   \end{align}
>   \right.
>   $$
>   由原方程等到
>
>   $nT(n) = 2\sum\limits_{i=1}^{n-1}T(i) + n^2-n$
>
>   $(n-1)T(n-1) = 2\sum\limits_{i=1}^{n-2}T(i) + (n-1)^2-(n-1)$
>
>   将两个方程相减，得到
>
>   $nT(n) - (n-1)T(n-1) = 2T(n-1)+2n-2$
>
>   化简得到
>
>   $nT(n) = (n+1)T(n-1) + 2n - 2$
>
>   变形
>
>   $\frac{T(n)}{n+1} = \frac{T(n-1)}{n} + \frac{2n-2}{n(n+1)} = $
>
>   迭代得到
>
>   $\frac{T(n)}{n+1} = 2(\frac{1}{n+1} + \frac{1}{n} + \cdots + \frac{1}{3}) + \frac{T(1)}{2} -1 + O(\frac{1}{n})$
>
>   括号内为调和级数之和，$\Theta(\log n)$
>
>   因此原递推方程的解为$T(n) = \Theta(n\log n)$

### 递归树

递归树是一棵结点带权的二叉树。根节点权为$W(n)$，不断迭代直到树中不再含有**权为函数**的结点为止。迭代规则就是将递归树中权为函数的结点，如$W(n),W(\frac{n}{2})$​，用**和这个函数相等的递推方程右部的**子树来代替。

以
$$
\left\{
\begin{align}
W(n) &= 2W(n/2) + n - 1,n = 2^k \\
W(1) &= 0
\end{align}
\right.
$$
为例：

![image-20240521133001843](./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521133001843.png)

整个迭代过程中，递归树中全部结点的**权之和不变**。

分层计算，上例中递归树有$k$层，各层结点的值之和分别为

$n-1,n-2,n-4,\cdots,n-2^{k-1}$

所以$W(n) = kn + \sum\limits_{i=1}^k2^{i-1} = n\log n - n + 1$

## 主定理

$设a \geq 1,b >1为常数，f(n) 为函数，T(n)为非负整数，且T(n) = aT(n/b) + f(n),则 $
$$
\begin{align}
若f(n) & = O(n^{\log_ba-\epsilon}),\epsilon>0,那么T(n) = \Theta(n^{\log_ba}) \\
若f(n) & = \Theta(n^{\log_ba}),那么T(n) = \Theta(n^{\log_ba}\log n) \\
若f(n) & = \Omega(n^{\log_ba+\epsilon}),\epsilon>0,且对于某个常数c<1和所有充分大的n，有af(n/b)\leq cf(n)，那么\\T(n) &= \Theta (f(n))
\end{align}
$$

$a代表递归调用所产生的子问题个数，n/b代表这些子问题的规模，f(n)代表调用前的操作及调用后把子问题的解组合成原问题的解的工作量。$

# 2 分治

将规模为n的原问题归约为规模减半的子问题。分别求解每个子问题，然后把子问题的解进行综合，从而得到原问题的解。

在分治算法中，常见的递推方程有以下两类：

-   $T(n) = \sum\limits_{i=1}^k a_iT(n-i) + f(n)$​
    -   子问题的规模比原问题呈现常数量级的减少
    -   汉诺塔问题
    -   迭代、递归树、尝试
-   $T(n) = aT(\frac{n}{b}) + d(n)$
    -   均衡划分的情况下，a代表子问题的个数，b代表子问题规模减少的倍数。$d(n)$表示归约过程和综合解过程的总工作量。
    -   迭代法、递归树、主定理

## 分治法的改进

减少子问题的个数。把某些工作提到递归过程之外。

寻找子问题之间的依赖关系。如果一个子问题的解可以用其他子问题的解通过简单的运算得到，那么在用到这个子问题的解时，不必重新递归计算，而是通过组合其他子问题的解来得到。

# 3 动态规划

求解的问题是多阶段决策（优化）问题；求解过程是多步判断，从小到大依次求解每个子问题，最后求解的子问题就是原始问题。

最优子结构性质：一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优的决策序列。

# 4 贪心

## 贪心算法的正确性证明

### 数学归纳法

对算法步数归纳，命题：对于任何正整数k，贪心法的前k步都导致最优解。

对问题规模归纳，命题：对于任何正整数k，贪心法对于规模为k的实例都得到最优解。

---

以装载问题为例。装载问题的贪心算法是轻者先装，直到装不下。

1.   叙述一个可以归纳证明的命题。

     对于任何正整数k，贪心算法都对k个集装箱的实例得到最优解。

2.   证明该命题

     1.   k=1，只有一个集装箱，其重量$w_1 \leq C$，(C为船最大装载量)任何算法都只有一种装法，就是将其装上船。得到最优解。

     2.   **假设**算法对于规模为k的输入都能得到最优解，考虑规模为$k+1$的输入$N = \{1,2,\cdots,k+1\},W = \{w_1,w_2,\cdots,w_{k+1}\}$,其中$w_1 \leq w_2 \leq \cdots \leq w_{k+1}$.从N中拿掉最轻的集装箱，于是得到
          $$
          N' = N - \{1\} = \{2,3,\cdots,k+1\} \\
          W' = W - \{w_1\} \\
          C' = C - w_1
          $$
          **根据归纳假设**，对于$N',W',C'$，算法得到最优解$I'$。令$I = I' \cup {1}$，那么$I$是$N$的最优解。这恰好也是算法对于$N,W,C$的解。

          **如若不然**，存在包含1的关于N的最优解$I^*$，且$|I^*| > |I|$。

          那么，$I^*-\{1\}$是关于$N’,W',C'$的解，且$|I^*-\{1\}| > |I-\{1\}| = |I'|$

          这与$I'$​的最优性**矛盾**。

     ---

### 交换论证法

从任意一个最优解出发，经过不断用新的成分替换解中的原有成分来改变这个解。在替换时要注意：

-   替换的目的是将它逐步改变成贪心法的解
-   替换中保证解的优化函数值不变坏
-   替换的步骤是有限的

通过有限步替换，将最优解改变成贪心法的解。由于替换中保证了贪心解的优化函数值至少和这个最优解的优化函数值一样好，从而证明了贪心法的解也是最优解。

---

以调度问题为例。给定集合$A = \{1,2,\cdots,n\},T = <t_1,t_2,\cdots,t_n>,D = <d_1,d_2,\cdots,d_n>$，求函数$f:A\rightarrow N$，使得
$$
\min\limits_f\{\max\limits_{i \in A}\{f(i) + t_i - d_i\}\}\\
\forall i,j \in A,i \neq j,f(i) + t_i \leq f(j) 或者 f(j) + t_j \leq f(i)
$$
贪心算法：按照截止时间$d_i$从小到大选择任务，在安排时不留空闲时间。

考虑调度$f$，如果$d_i < d_j$，但是$f(i) > f(j)$，换句话说，完成时间较早的任务$i$反而被安排在完成时间较晚的任务$j$后面，就称$<i,j>$是$f$的一个逆序。一般最优解可能存在逆序，但是算法的解没有逆序。这是算法得到的解与一般最优解的区别：没有空闲时间，没有逆序。

如果一个最优解有空闲时间$t$，我们可以将安排在空闲时间后面客户的服务都前移$t$个时间单位，得到的仍旧是最优解。于是转换从一个没有空闲时间的最优解开始。

1.   引理：所有没有逆序，没有空闲时间的调度具有相同的最大延迟。
2.   定理：在一个没有空闲时间的最优解中，最大延迟是$r$，如果仅对具有相邻逆序的客户进行交换，得到的解的最大延迟不会超过$r$

## 经典例题

### 最优前缀码

-   哈夫曼树

### 最小生成树

设无向连通带权图$G = <V,E,W>$，其中$w(e) \in W$是边$e$的权。$G$的一棵生成树是包含了$G$的所有顶点的树，树中各边的权之和称为树的权。具有最小权的生成树称为$G$的最小生成树。给定连通带权图$G$，求$G$的一棵最小生成树。

-   Prim算法

    将图分成两个子图，每次选连接两个子图中权最小的边。

-   Kruskal算法

    每次选全局最短的边

### 单源最短路

在一个带权有向网络$G = <V,E,W>$中，每条边$e = <i,j>$的权$w(e)$为非负实数，表示从$i$到$j$的距离。网络中有源点 $ s \in V$ ，求从$s$出发到达每个其他结点的最短路径。

-   Dijkstrla算法

    将V划分成集合S与V-S。初始$S = \{s\}$，算法的每一步都把1个结点加入$S$，直到$S = V$为止。

    对每个结点$i \in V - S$，计算从$s$出发中间只经过$S$中结点且最终到达$i$的最短路径，称为从$s$到$i$相对于$S$的最短路径。路径长度记为$dist[i]$（如果此刻$s$到$i$不可达，则令$dist[i] = \infty$）。通过比较，从所有$dist[i](i \in V-S)$中选出最小值，加入$S$中的结点。

    

    Dijkstrla

    ---

    输入：带权有向图$G = <V,E,W>$，源点$s \in V$

    输出：数组$L$，对所有$j \in V-\{s\}$，$L[j]$表示$s$到$j$的最短路径上$j$前一个结点的标号

    1. $~ S \leftarrow \{s\}$ 
    2.  $dist[s] \leftarrow 0 $
    3.  $for ~ i \in V - \{s\} do$
    4.  $dist[i] \leftarrow w(s,i)$
    5.  $while ~ V-S \neq \emptyset ~ do$
    6. ​         $从V-S中取出具有相对S的最短路径的结点j,k是该路径上连接j的结点$
    7.  $S \leftarrow S \cup \{j\};L[j] \leftarrow k$
    8. $for ~ i \in V-S ~ do$
    9. ​        $if ~ dist[j] + w(j,i) < dist[i]$
    10. ​        $then ~ dist[i] \leftarrow dist[j] + w(j,i)$

# 5 回溯与分支限界

搜索问题/优化问题的解分布在一个解空间中。求解**搜索问题**就是在搜索空间中找到一个或全部解，求解**组合优化问题**就是找到该问题的一个最优解或所有最优解。

回溯算法将搜索空间看作一定的结构，通常为**树形结构**。**一个解**对应于树中的**一片树叶**。

## 适用条件

满足**多米诺性质**：

$假设P(x_1,x_2,\cdots,x_i)是关于向量<x_1,x_2,\cdots,x_i>的某个性质，那么P(x_1,x_2,\cdots,x_{i+1})是真蕴含P(x_1,x_2,\cdots,x_i)为真。$

即

$P(x_1,x_2,\cdots,x_{k+1}) \rightarrow P(x_1,x_2,\cdots,x_k),0<k<n$

其中$n$​代表解向量的维数。

-   如果当前结点不满足约束条件，能够推导出它的子结点也不满足约束条件。
-   如果子结点满足约束条件，能够推导出其父结点满足约束条件。

*结点的三种状态*

-   白结点：尚未访问
-   灰结点：正在访问以该结点为根的树中结点
-   黑结点：该结点为根的子树遍历完成

## 回溯算法的设计步骤

-   定义搜索问题的解向量和每个分量的取值范围
-   确定子节点的排列规则
-   判断是否满足多米诺性质
-   确定搜索策略：深度优先、宽度优先、宽深结合
-   确定每个结点能够分支的约束条件
-   确定存储搜索路径的数据结构

>   设解向量为$<x_1,x_2,\cdots,x_n>$，$x_i$的可能取值的集合为$X_i$，$i=1,2,\cdots,n$.设当$x_1,x_2,\cdots,x_{k-1}$确定以后$x_k$的取值集合为$S_k$，显然$S_k \subseteq X_k$

### 回溯算法的递归实现和迭代实现

<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142739670.png" alt="image-20240521142739670" style="zoom:33%;" />

注意第5步中的“计算$S_{k+1}$”是指：在限制条件之下，找一个满足条件的$S_{k+1}$。

<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142746237.png" alt="image-20240521142746237" style="zoom:33%;" />
<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142752389.png" alt="image-20240521142752389" style="zoom:33%;" />
<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142800193.png" alt="image-20240521142800193" style="zoom:33%;" />

## 回溯算法的效率估计和改进途径

回溯算法的时间复杂度一般取决于在搜索空间中真正遍历的结点个数以及在每个结点的工作量。采用蒙特卡洛方法来估计搜索树中真正遍历的结点数。

### 蒙特卡洛法估计回溯法效率

设$t$为取样次数，$sum$为$t$次取样遍历节点的平均数，$m$为本次取样树种结点总数，$k$为目前访问结点的层数，$r_1$为在路径中的本层分支数，$r_2$为路径中的上层分支层数，$n$为树的层数。

![image-20240521143535424](./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521143535424.png)

### 影响回溯算法效率的因素

-   搜索树的结构。如分支情况、树的深度。
-   解的分布。如解在树种是否均匀分布等。
-   约束条件的计算复杂性

### 改进回溯算法的途径

-   根据树的分支情况设计优先策略。结点少的分支先搜索，解多的分支优先搜索。
-   利用搜索树的对称性裁剪子树
-   分解为子问题，先搜索子问题，然后组合子问题的解。

## 分支限界

分支限界是回溯算法的变种，用于求解**组合优化**问题。以**极大化**组合优化问题为例：

-   代价函数：函数值是当搜索进行到此结点时，以后无论怎么选择此结点的后代，目标函数所能达到的最大值不会超过代价函数的值。代价函数在父结点的值**大于或等于**在子结点的值。
-   界函数：函数值是搜索到此结点时已经得到的可行解的目标函数的最大值。
-   如果某个节点不满足约束条件或者其代价函数**小于**当时的界函数，则不再分支，向上回溯到父节点。

对于极小化问题，需要将上述内容对偶。

## 经典例题

### n皇后问题

#### 题目

在一个n*n个方格的棋盘中放置n个皇后，使得在同一行、同一列、主对角线、副对角线的平行线上，不能有两个及以上的皇后，给出所有放置方法。

---

#### 思路

搜索过程是解向量不断生成的过程。根结点为空向量，算法依次对$x_1,x_2,\cdots,x_8$​赋值。

每次赋值检查”互不攻击“的条件，若不满足，不再继续向下搜索，而是返回父节点。

1.   定义搜索问题的解向量和每个分量的取值范围

     -   解向量：$<x_1,x_2,\cdots,x_n>$，其中$x_i$表示第$i$行放置皇后的列号。

     -   每个分量$x_i$的取值范围$X_i = \{x_i|1 \leq x_i \leq n\}$​

2.   确定子结点的排列规则

3.   判断是否满足多米诺性质

     当$x_1,x_2,\cdots,x_{k-1}$确定以后，$x_k$的取值集合为$S_k$，则$S_k$为与前$k-1$个皇后位置不冲突的位置。显然$S_k \subseteq X_k$

4.   确定搜索策略：深度优先

5.   确定每个结点能够分支的条件

     定义函数判断皇后之间是否冲突

     ```python
     def nqueen(n):
         # 检查是否有冲突
         def conflict(state, nextX):
             # len(state)表示已经放置的皇后个数
             # nextY表示下一个皇后的行号
             nextY = len(state)
             for i in range(nextY):
                 # 如果abs(state[i] - nextX)==0为True，表示下一个皇后和第i个皇后在同一列
                 # 如果abs(state[i] - nextX)==nextY - i为True，表示下一个皇后和第i个皇后在同一斜线
                 if abs(state[i] - nextX) in (0, nextY - i):
                     return True
             return False
     ```

6.   确定存储搜索路径的数据结构

     使用列表即可。

---

#### 时间复杂度分析

对于$n$皇后问题，搜索树一共有$1+n+n^2+\cdots+n^n \leq 2n^n$个结点。

在每个结点处，要看$3n$个位置。

时间复杂度为$O(3n \times 2n^n) = O(n^{n+1})$​

采用在搜索树中真正遍历的结点数作为度量标准，采用蒙特卡罗法估计。

### 背包问题

#### 题目

可放入背包的物品有$N$种，第$i$种物品有$n_i$个，重量和价值分别为$w_j$和$v_j$，$1 \leq j \leq N$。背包最大重量限制为$B$​。怎样选择放入背包的物品，使背包的价值最大？

>   可以转化为如下的实例
>   $$
>   \max \{x_1 + 3x_2 + 5x_3 + 9x_4\} \\
>   2x_1 + 3x_2 + 4x_3 + 7x_4 \leq 10 \\
>   x_i \in N ,i = 1,2,3,4 \\
>   每一个维度的x有对应的取值范围，且是正整数。
>   $$

---

#### 思路

1.   定义搜索问题的解向量和每个分量的取值范围

     -   解向量：$<x_1,x_2,\cdots,x_n>$，表示第$i$个物品放$x_i$个进背包

     -   每个分量$x_i$的取值范围$X_i = \{x_i|1 \leq x_i \leq n_i\ \& x_i \leq  \lfloor B/w_i \rfloor \}$

2.   确定子结点的排列规则

     

     **分支限界**

     对变元按照$\frac{v_i}{w_i} \geq \frac{v_{i+1}}{w_{i+1}}$重新排序。结点的代价函数**值**为：$在<x_1,x_2,\cdots,x_k,x_{k+1},\cdots,x_n>$中，无论$x_{k+1},\cdots,x_n$取何值，都取$\sum\limits_{i=1}^nv_ix_i$的一个上界。该上界为：
     $$
     \left\{
     \begin{align}
     & \sum\limits_{i=1}^nv_ix_i + (B-\sum\limits_{i=1}^nw_ix_i)\frac{v_{k+1}}{w_{k+1}} & 如果对于某个j>k，有B-\sum\limits_{i=1}^nw_ix_i \geq w_j \\
     & \sum\limits_{i=1}^nv_ix_i & 否则
     \end{align}
     \right.
     $$
     也就是说，上界应该是**$剩余空间\times 第k+1个物品的单位重量下的价值 + 当前价值$**（当剩余空间能够放得下第$k+1$​个或其以后的某个物品）

     

     对于每个内结点来说，到达左子结点的边代表1，到达右子结点的边代表0。

3.   判断是否满足多米诺性质

     当$x_1,x_2,\cdots,x_{k-1}$确定以后，$x_k$的取值集合为$S_k$，则$S_k$为放入/不放入第$k$个物品后，背包仍能承受相应重量。显然$S_k \subseteq X_k$

4.   确定搜索策略：深度优先

5.   确定每个结点能够分支的条件

     放入/不放入第$k$个物品后，背包仍能承受相应重量。

6.   确定存储搜索路径的数据结构

     使用列表即可。

---

#### 时间复杂度分析

子集树共有$1+2+2^2+\cdots+2^n = 2^{n+1}-1 \leq 2 \times 2^n = O(2^n)$个结点。每个结点要计算放入背包的重量是否超过背包的承载量，父结点已经记录了在此结点之前已经放入背包物品的重量。只进行一次加法运算和一次大小比较，$O(1)$。从而算法在最坏的情况下复杂性$O(2^n)$。

对于一般的背包问题，其可行解和0-1背包问题类似，也是$n$维向量$<x_1,x_2,\cdots,x_n>$。只不过其分量$x_i$是整数。取值范围变成$0 \leq x_i \leq \lfloor B/w_i \rfloor$

### 货郎问题(TSP)

#### 问题

已知一个带权完全图，求权和最短的哈密顿回路。

---

#### 思路

1.   定义搜索问题的解向量和每个分量的取值范围

     -   解向量：$<x_1,x_2,\cdots,x_n>$，表示$n$个城市的一个排列，第一个元素是出发点，最后一个元素是最后到达的城市，由此城市回到驻地。

     -   每个分量$x_i$的取值范围$X_i = \{x_i|1 \leq x_i \leq n \}$​

2.   确定子结点的排列规则

     根结点只有一个子结点，其余各节点分支数不同。第一层有n-1个分支，第二层有n-2个分支……，第n-1层有1个分支。这样的树称为**排列树**。

     ![image-20240521163415524](./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521163415524.png)

     **分支限界**

     界：当前得到的最短巡回路线长度

     代价函数L：设$c_j$为已得到的巡回路线中第$j$段的长度，$1 \leq j \leq k$,$l_d$为从顶点$d$出发的最短边长度，则

     $L = \sum\limits_{j=1}^kc_j + (l_{ik} + \sum\limits_{ij \notin B}l_{ij})$

3.   判断是否满足多米诺性质

     当$x_1,x_2,\cdots,x_{k-1}$确定以后，$x_k$的取值集合为$S_k$，则$S_k$为货郎下一个到达的地方。

4.   确定搜索策略：深度优先

5.   确定每个结点能够分支的条件

     存在路径

6.   确定存储搜索路径的数据结构

     使用列表即可。

---

#### 时间复杂度分析

该排列树有$K_n = 1 + 1 + (n-1) + (n-1)(n-2) + \cdots + ((n-1)(n-2)\cdots2) + (n-1)!$个结点

$K_n = O((n-1)!)$

在每个结点处要计算已得到的路径长度，只需要将父结点得到的路径长度加上父结点到本结点的距离即可。在叶结点处要计算得到的回路长度，并判断是否为最短回路。只需要在每个结点处进行两次加法和一次大小比较。故该算法最坏情况下时间复杂性为$O((n-1)!)\times O(1) = O((n-1)!)$​

---

### 装载问题

#### 题目

将$n$个集装箱装上两艘载重分别为$c_1$和$c_2$的轮船，$w_i$为集装箱$i$的重量，且$\sum\limits_{i=1}^n w_i \leq c_1 + c_2$，问是否存在一种合理的装载方案，将$n$个集装箱装上轮船？

---

#### 思路

如果装载问题有解，则存在一个使得第一条船的实际装载量与$c_1$的差最小的解。从而可以使用回溯法，确定一个装载方案，使得第一条船的实际装载量$W_1$最大，并比较 货物总重与剩余货物的差 与第二条穿载重的大小。

1.   定义解向量、每个分量的取值范围、约束条件。

     -   解向量：$<x_1,x_2,\cdots,x_n>$，其中$x_i$表示第$i$个货物是否放入第一条船。
     -   每个分量$x_i$的取值范围$x_i \in \{0,1\}$​
     -   约束条件：$\sum\limits_{i=1}^kw_ix_i \leq c_1$
     -   搜索空间为子集树

2.   判断是否满足多米诺性质

     令$P(x_1,x_2,\cdots,x_k)$为$\sum\limits_{i=1}^kw_ix_i > c_1$，从而
     $$
     \sum\limits_{i=1}^kw_ix_i > c_1 \rightarrow \sum\limits_{i=1}^{k+1}w_ix_i > c_1
     $$

3.   确定搜索策略：深度优先

---

#### 算法描述

Loading(W,c1)

输入：集装箱重量$W = <w_1,w_2,\cdots,w_n>$，$c_1$是第一条船的载重

输出：使得第一条船装载量最大的装载方案$<x_1,x_2,\cdots,x_n>$，其中$x_i \in {0,1}$

1.   

---

#### 算法时间复杂度分析

叶结点有$2^n$个，结点总数$O(2^n)$个，每个结点要计算装载量以判断是否回溯，到达叶结点的计算时间为$O(1)$，所以算法的计算时间复杂度为$O(2^n)$

### 图的m着色问题

### 最大团问题

### 圆排列问题

### 连续邮资问题

## 6 线性规划



