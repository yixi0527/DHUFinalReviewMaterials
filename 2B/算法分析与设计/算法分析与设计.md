# 1 基础知识

- 算法由有限条指令构成，每条指令规定了计算机所要执行的有限次运算或者操作。
- “有着本质改进的高效算法”：算法的时间复杂度由指数函数降为多项式函数。

## 时间复杂度

- 最坏情况下的时间复杂度$W(n)$

- 平均情况下的时间复杂度$A(n)$​

    给出规模为$n$的所有输入实例的概率分布。

    假定实例集合为$S$，实例$I \in S$出现的概率为$p_i$，算法对于$I$所做的基本运算次数为$t_I$，那么平均情况下的时间复杂度为$\sum\limits_{i=1}t_Ip_I$。

>   例：顺序检索
>
>   假定检索值$x$在$L$中的概率为$p$，且处在$L$每个位置的概率相等。
>
>   $A(n) = \sum\limits_{i=1}^n i \frac{p}{n} + (1-p)n$ 

## 算法的伪码描述

-   赋值 $\leftarrow$
-   分支 $if \cdots then \cdots [else \cdots]$
-   循环 while,for,repeat until
-   转向：goto
-   输出：return
-   调用：.
-   注释：$//\cdots$

## 算法的数学基础

### 函数的渐近的界

#### 基本概念

$\exist n_0 > 0,\forall n \geq n_0$的实际含义是，数据输入达到了一定的规模。

-   $若\exist c>0,n_0>0,使得\forall n\geq n_0,有0 \leq f(n) \leq cg(n) 成立，则称f(n)的渐近的上界是g(n),记作f(n) = O(g(n))$

    >   对于函数$g(n)$，**仅需**乘上一个常数$c$就可以让它不严格地大于$f(n)$，则$g(n)$是$f(n)$的渐近的上界。这意味着$f(n)$的阶可能等于$g(n)$的阶，也可能小于$g(n)$的阶。

-   $若\exist c>0,n_0>0,使得\forall n\geq n_0,有0 \leq cg(n) \leq f(n) 成立，则称f(n)的渐近的下界是g(n),记作f(n) = \Omega(g(n))$

    >   对于函数$g(n)$，**即使**乘上一个常数$c$，也还是会不严格地小于$f(n)$，则$g(n)$是$f(n)$的渐近的下界。这意味着$f(n)$的阶只可能小于$g(n)$的阶。

-   $若\forall c>0, \exist n_0,使得当n \geq n_0 时有0 \leq f(n) <cg(n)成立，则称f(n)的非紧上界是g(n),记作f(n) = o(g(n))$

    >   对于函数$g(n)$，**即使**乘上任意一个**可以非常非常小**的数$c$，也还是会严格地大于$f(n)$，则$g(n)$是$f(n)$的非紧上界。

-   $若\forall c>0, \exist n_0,使得当n \geq n_0 时有0 \leq cg(n) < f(n)成立，则称f(n)的非紧下界是g(n),记作f(n) = \omega(g(n))$

    >   对于函数$g(n)$，**即使**乘上任意一个**可以非常非常大**的数$c$，也还是会严格地小于$f(n)$，则$g(n)$是$f(n)$的非紧下界。

-   $若f（n） = O(g(n)) 且 f(n) = \Omega(g(n)),则称f(n)的渐近紧界是g(n),记作f(n) = \Theta(g(n))$​

    >   例：
    >
    >   对于函数$f(n) = n^2 + n$
    >
    >   可以写为：$f(n) = O(n^2),f(n) = O(n^3),f(n) = o(n^3)$
    >
    >   但是不能写为$f(n) = o(n^2)$

#### 相关定理

-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)}存在且值等于某个常数c>0,那么f(n) = \Theta(g(n))$
-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)} = 0,那么f(n) = o(g(n))$
-   $如果\lim\limits_{n \rightarrow \infty}\frac{f(n)}{g(n)} = +\infty,那么f(n) = \omega(g(n))$​
-   $如果f = O(h),g = O(h),那么f+g = O(h)$​
-   $f = \Theta(f)$
-   $如果g= O(f),那么f+g = \Theta(f)$

#### 相关性质

-   $如果f=O(g),g=O(h),那么f=O(h)$

-   $如果f=\Omega(g),g=\Omega(h),那么f=\Omega(h)$

-   $如果f=\Theta(g),g=\Theta(h),那么f=\Theta(h)$​

-   有些函数中的$n$虽然表面上看处在指数位置，但仍有可能是多项式函数。


>   $a^{\log_bn} = n^{\log_ba}$ ，只要对等式两边取以$b$为底的对数，都会得到$\log_ba\cdot\log_bn$

-   对于不同的底数，指数函数的阶是不相同的。底越大，指数函数的阶就越高。
-   $n! = o(n^n),n! = \omega(2^n),\log(n!) = \Theta(n\log n)$​

### 求和的方法

$$
\sum\limits_{k=1}^n a_k = \frac{(a_1+a_n)n}{2} \\
\sum\limits_{k=0}^n aq^k = \frac{a(1-q^{n+1})}{1-q}\\
\sum\limits_{k=1}^n \frac{1}{k} = \ln n+O(1)
$$

#### 放大方法

假设存在常数$r<1$，使得$\frac{a_{k+1}}{a_k}\leq r$对一切$k \geq 0$成立，那么有
$$
\sum\limits_{k=0}^n a_k \leq \sum\limits_{k=0}^\infty a_0r^k = a_0\sum\limits_{k=0}^\infty r^k = \frac{a_0}{1-r}
$$

>   例：
>
>   估计$\sum\limits_{k=1}^n\frac{k}{3^k}$​的上界
>
>   解：
>
>   由$a_k = \frac{k}{3^k},a_{k+1} = \frac{k+1}{3^{k+1}}$得
>
>   $\frac{a_{k+1}}{a_k} = \frac{1}{3}\frac{k+1}{k} \leq \frac{2}{3}$
>
>   从而得到
>
>   $\sum\limits_{k=1}^n \frac{k}{3^k} \leq \sum\limits_{k=1}^\infty \frac{1}{3} (\frac{2}{3})^{k-1} = 1$​

## 递归方程求解方法

### 迭代法

>   例：
>   $$
>   \left\{ 
>   \begin{aligned}
>   W(n) & = &  W(n-1) + n - 1 \\
>   W(1) & = & 0
>   \end{aligned}
>   \right.
>   $$
>   解：
>   $$
>   \begin{align}
>   W(n) & =  W(n-1) + n-1 \\
>   & =  [W(n-2)+n-1] + n-1 = W(n-2)+(n-2)+(n-1) \\
>   & =  W(n-3) + (n-3) + (n-2) + (n-1) \\
>   & =  \cdots \\
>   & =  W(1) + 1 + 2 + \cdots + (n-1) \\
>   & =  0+1+2+\cdots+(n-1) \\
>    & = \frac{n(n-1)}{2} 
>   \end{align}
>   $$
>   归纳验证：
>
>   当$n=1$时，$W(1) = 0$符合给定的初值。
>
>   假设对于$n$，有$W(n) = \frac{(n-1)n}{2}$，那么
>
>   $W(n+1) = W(n) + n = \frac{n(n+1)}{2}$
>
>   从而证明了$W(n) = \frac{n(n-1)}{2}$​是原递推方程的解。

### 差消法

**全部历史递推方程**：$T(n)$依赖于$T(n-1),T(n-2),\cdots,T(1),T(0)等所有的项$

>   例：
>
>   求解下述递推方程：
>   $$
>   \left\{
>   \begin{align}
>   T(n) &= \frac{2}{n}\sum\limits_{i=1}^{n-1}T(i) + n-1 \\
>   T(1) &= 0
>   \end{align}
>   \right.
>   $$
>   由原方程等到
>
>   $nT(n) = 2\sum\limits_{i=1}^{n-1}T(i) + n^2-n$
>
>   $(n-1)T(n-1) = 2\sum\limits_{i=1}^{n-2}T(i) + (n-1)^2-(n-1)$
>
>   将两个方程相减，得到
>
>   $nT(n) - (n-1)T(n-1) = 2T(n-1)+2n-2$
>
>   化简得到
>
>   $nT(n) = (n+1)T(n-1) + 2n - 2$
>
>   变形
>
>   $\frac{T(n)}{n+1} = \frac{T(n-1)}{n} + \frac{2n-2}{n(n+1)} = $
>
>   迭代得到
>
>   $\frac{T(n)}{n+1} = 2(\frac{1}{n+1} + \frac{1}{n} + \cdots + \frac{1}{3}) + \frac{T(1)}{2} -1 + O(\frac{1}{n})$
>
>   括号内为调和级数之和，$\Theta(\log n)$
>
>   因此原递推方程的解为$T(n) = \Theta(n\log n)$

### 递归树

递归树是一棵结点带权的二叉树。根节点权为$W(n)$，不断迭代直到树中不再含有**权为函数**的结点为止。迭代规则就是将递归树中权为函数的结点，如$W(n),W(\frac{n}{2})$​，用**和这个函数相等的递推方程右部的**子树来代替。

以
$$
\left\{
\begin{align}
W(n) &= 2W(n/2) + n - 1,n = 2^k \\
W(1) &= 0
\end{align}
\right.
$$
为例：

![image-20240521133001843](./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521133001843.png)

整个迭代过程中，递归树中全部结点的**权之和不变**。

分层计算，上例中递归树有$k$层，各层结点的值之和分别为

$n-1,n-2,n-4,\cdots,n-2^{k-1}$

所以$W(n) = kn + \sum\limits_{i=1}^k2^{i-1} = n\log n - n + 1$

## 主定理

$设a \geq 1,b >1为常数，f(n) 为函数，T(n)为非负整数，且T(n) = aT(n/b) + f(n),则 $
$$
\begin{align}
若f(n) & = O(n^{\log_ba-\epsilon}),\epsilon>0,那么T(n) = \Theta(n^{\log_ba}) \\
若f(n) & = \Theta(n^{\log_ba}),那么T(n) = \Theta(n^{\log_ba}\log n) \\
若f(n) & = \Omega(n^{\log_ba+\epsilon}),\epsilon>0,且对于某个常数c<1和所有充分大的n，有af(n/b)\leq cf(n)，那么\\T(n) &= \Theta (f(n))
\end{align}
$$

$a代表递归调用所产生的子问题个数，n/b代表这些子问题的规模，f(n)代表调用前的操作及调用后把子问题的解组合成原问题的解的工作量。$

# 2 分治

# 3 动态规划

# 4 贪心

# 5 回溯与分支限界

搜索问题/优化问题的解分布在一个解空间中。求解**搜索问题**就是在搜索空间中找到一个或全部解，求解**组合优化问题**就是找到该问题的一个最优解或所有最优解。

回溯算法将搜索空间看作一定的结构，通常为**树形结构**。**一个解**对应于树中的**一片树叶**。

## 适用条件

满足**多米诺性质**：

$假设P(x_1,x_2,\cdots,x_i)是关于向量<x_1,x_2,\cdots,x_i>的某个性质，那么P(x_1,x_2,\cdots,x_{i+1})是真蕴含P(x_1,x_2,\cdots,x_i)为真。$

即

$P(x_1,x_2,\cdots,x_{k+1}) \rightarrow P(x_1,x_2,\cdots,x_k),0<k<n$

其中$n$​代表解向量的维数。

-   如果当前结点不满足约束条件，能够推导出它的子结点也不满足约束条件。
-   如果子结点满足约束条件，能够推导出其父结点满足约束条件。

*结点的三种状态*

-   白结点：尚未访问
-   灰结点：正在访问以该结点为根的树中结点
-   黑结点：该结点为根的子树遍历完成

## 回溯算法的设计步骤

-   定义搜索问题的解向量和每个分量的取值范围
-   确定子节点的排列规则
-   判断是否满足多米诺性质
-   确定搜索策略：深度优先、宽度优先、宽深结合
-   确定每个结点能够分支的约束条件
-   确定存储搜索路径的数据结构

>   设解向量为$<x_1,x_2,\cdots,x_n>$，$x_i$的可能取值的集合为$X_i$，$i=1,2,\cdots,n$.设当$x_1,x_2,\cdots,x_{k-1}$确定以后$x_k$的取值集合为$S_k$，显然$S_k \subseteq X_k$

### 回溯算法的递归实现和迭代实现

<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142739670.png" alt="image-20240521142739670" style="zoom:33%;" />

注意第5步中的“计算$S_{k+1}$”是指：在限制条件之下，找一个满足条件的$S_{k+1}$。

<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142746237.png" alt="image-20240521142746237" style="zoom:33%;" />
<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142752389.png" alt="image-20240521142752389" style="zoom:33%;" />
<img src="./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521142800193.png" alt="image-20240521142800193" style="zoom:33%;" />

## 回溯算法的效率估计和改进途径

回溯算法的时间复杂度一般取决于在搜索空间中真正遍历的结点个数以及在每个结点的工作量。采用蒙特卡洛方法来估计搜索树中真正遍历的结点数。

### 蒙特卡洛法估计回溯法效率

设$t$为取样次数，$sum$为$t$次取样遍历节点的平均数，$m$为本次取样树种结点总数，$k$为目前访问结点的层数，$r_1$为在路径中的本层分支数，$r_2$为路径中的上层分支层数，$n$为树的层数。

![image-20240521143535424](./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521143535424.png)

### 影响回溯算法效率的因素

-   搜索树的结构。如分支情况、树的深度。
-   解的分布。如解在树种是否均匀分布等。
-   约束条件的计算复杂性

### 改进回溯算法的途径

-   根据树的分支情况设计优先策略。结点少的分支先搜索，解多的分支优先搜索。
-   利用搜索树的对称性裁剪子树
-   分解为子问题，先搜索子问题，然后组合子问题的解。

## 分支限界

分支限界是回溯算法的变种，用于求解**组合优化**问题。以**极大化**组合优化问题为例：

-   代价函数：函数值是当搜索进行到此结点时，以后无论怎么选择此结点的后代，目标函数所能达到的最大值不会超过代价函数的值。代价函数在父结点的值**大于或等于**在子结点的值。
-   界函数：函数值是搜索到此结点时已经得到的可行解的目标函数的最大值。
-   如果某个节点不满足约束条件或者其代价函数**小于**当时的界函数，则不再分支，向上回溯到父节点。

对于极小化问题，需要将上述内容对偶。

## 经典例题

### n皇后问题

#### 题目

在一个n*n个方格的棋盘中放置n个皇后，使得在同一行、同一列、主对角线、副对角线的平行线上，不能有两个及以上的皇后，给出所有放置方法。

---

#### 思路

搜索过程是解向量不断生成的过程。根结点为空向量，算法依次对$x_1,x_2,\cdots,x_8$​赋值。

每次赋值检查”互不攻击“的条件，若不满足，不再继续向下搜索，而是返回父节点。

1.   定义搜索问题的解向量和每个分量的取值范围

     -   解向量：$<x_1,x_2,\cdots,x_n>$，其中$x_i$表示第$i$行放置皇后的列号。

     -   每个分量$x_i$的取值范围$X_i = \{x_i|1 \leq x_i \leq n\}$​

2.   确定子结点的排列规则

3.   判断是否满足多米诺性质

     当$x_1,x_2,\cdots,x_{k-1}$确定以后，$x_k$的取值集合为$S_k$，则$S_k$为与前$k-1$个皇后位置不冲突的位置。显然$S_k \subseteq X_k$

4.   确定搜索策略：深度优先

5.   确定每个结点能够分支的条件

     定义函数判断皇后之间是否冲突

     ```python
     def nqueen(n):
         # 检查是否有冲突
         def conflict(state, nextX):
             # len(state)表示已经放置的皇后个数
             # nextY表示下一个皇后的行号
             nextY = len(state)
             for i in range(nextY):
                 # 如果abs(state[i] - nextX)==0为True，表示下一个皇后和第i个皇后在同一列
                 # 如果abs(state[i] - nextX)==nextY - i为True，表示下一个皇后和第i个皇后在同一斜线
                 if abs(state[i] - nextX) in (0, nextY - i):
                     return True
             return False
     ```

6.   确定存储搜索路径的数据结构

     使用列表即可。

---

#### 时间复杂度分析

对于$n$皇后问题，搜索树一共有$1+n+n^2+\cdots+n^n \leq 2n^n$个结点。

在每个结点处，要看$3n$个位置。

时间复杂度为$O(3n \times 2n^n) = O(n^{n+1})$​

采用在搜索树中真正遍历的结点数作为度量标准，采用蒙特卡罗法估计。

### 背包问题

#### 题目

可放入背包的物品有$N$种，第$i$种物品有$n_i$个，重量和价值分别为$w_j$和$v_j$，$1 \leq j \leq N$。背包最大重量限制为$B$​。怎样选择放入背包的物品，使背包的价值最大？

>   可以转化为如下的实例
>   $$
>   \max \{x_1 + 3x_2 + 5x_3 + 9x_4\} \\
>   2x_1 + 3x_2 + 4x_3 + 7x_4 \leq 10 \\
>   x_i \in N ,i = 1,2,3,4 \\
>   每一个维度的x有对应的取值范围，且是正整数。
>   $$

---

#### 思路

1.   定义搜索问题的解向量和每个分量的取值范围

     -   解向量：$<x_1,x_2,\cdots,x_n>$，表示第$i$个物品放$x_i$个进背包

     -   每个分量$x_i$的取值范围$X_i = \{x_i|1 \leq x_i \leq n_i\ \& x_i \leq  \lfloor B/w_i \rfloor \}$

2.   确定子结点的排列规则

     

     **分支限界**

     对变元按照$\frac{v_i}{w_i} \geq \frac{v_{i+1}}{w_{i+1}}$重新排序。结点的代价函数**值**为：$在<x_1,x_2,\cdots,x_k,x_{k+1},\cdots,x_n>$中，无论$x_{k+1},\cdots,x_n$取何值，都取$\sum\limits_{i=1}^nv_ix_i$的一个上界。该上界为：
     $$
     \left\{
     \begin{align}
     & \sum\limits_{i=1}^nv_ix_i + (B-\sum\limits_{i=1}^nw_ix_i)\frac{v_{k+1}}{w_{k+1}} & 如果对于某个j>k，有B-\sum\limits_{i=1}^nw_ix_i \geq w_j \\
     & \sum\limits_{i=1}^nv_ix_i & 否则
     \end{align}
     \right.
     $$
     也就是说，上界应该是**$剩余空间\times 第k+1个物品的单位重量下的价值 + 当前价值$**（当剩余空间能够放得下第$k+1$​个或其以后的某个物品）

     

     对于每个内结点来说，到达左子结点的边代表1，到达右子结点的边代表0。

3.   判断是否满足多米诺性质

     当$x_1,x_2,\cdots,x_{k-1}$确定以后，$x_k$的取值集合为$S_k$，则$S_k$为放入/不放入第$k$个物品后，背包仍能承受相应重量。显然$S_k \subseteq X_k$

4.   确定搜索策略：深度优先

5.   确定每个结点能够分支的条件

     放入/不放入第$k$个物品后，背包仍能承受相应重量。

6.   确定存储搜索路径的数据结构

     使用列表即可。

---

#### 时间复杂度分析

子集树共有$1+2+2^2+\cdots+2^n = 2^{n+1}-1 \leq 2 \times 2^n = O(2^n)$个结点。每个结点要计算放入背包的重量是否超过背包的承载量，父结点已经记录了在此结点之前已经放入背包物品的重量。只进行一次加法运算和一次大小比较，$O(1)$。从而算法在最坏的情况下复杂性$O(2^n)$。

对于一般的背包问题，其可行解和0-1背包问题类似，也是$n$维向量$<x_1,x_2,\cdots,x_n>$。只不过其分量$x_i$是整数。取值范围变成$0 \leq x_i \leq \lfloor B/w_i \rfloor$

### 货郎问题(TSP)

#### 问题

已知一个带权完全图，求权和最短的哈密顿回路。

---

#### 思路

1.   定义搜索问题的解向量和每个分量的取值范围

     -   解向量：$<x_1,x_2,\cdots,x_n>$，表示$n$个城市的一个排列，第一个元素是出发点，最后一个元素是最后到达的城市，由此城市回到驻地。

     -   每个分量$x_i$的取值范围$X_i = \{x_i|1 \leq x_i \leq n \}$​

2.   确定子结点的排列规则

     根结点只有一个子结点，其余各节点分支数不同。第一层有n-1个分支，第二层有n-2个分支……，第n-1层有1个分支。这样的树称为**排列树**。

     ![image-20240521163415524](./%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.assets/image-20240521163415524.png)

     **分支限界**

     界：当前得到的最短巡回路线长度

     代价函数L：设$c_j$为已得到的巡回路线中第$j$段的长度，$1 \leq j \leq k$,$l_d$为从顶点$d$出发的最短边长度，则

     $L = \sum\limits_{j=1}^kc_j + (l_{ik} + \sum\limits_{ij \notin B}l_{ij})$

3.   判断是否满足多米诺性质

     当$x_1,x_2,\cdots,x_{k-1}$确定以后，$x_k$的取值集合为$S_k$，则$S_k$为货郎下一个到达的地方。

4.   确定搜索策略：深度优先

5.   确定每个结点能够分支的条件

     存在路径

6.   确定存储搜索路径的数据结构

     使用列表即可。

---

#### 时间复杂度分析

该排列树有$K_n = 1 + 1 + (n-1) + (n-1)(n-2) + \cdots + ((n-1)(n-2)\cdots2) + (n-1)!$个结点

$K_n = O((n-1)!)$

在每个结点处要计算已得到的路径长度，只需要将父结点得到的路径长度加上父结点到本结点的距离即可。在叶结点处要计算得到的回路长度，并判断是否为最短回路。只需要在每个结点处进行两次加法和一次大小比较。故该算法最坏情况下时间复杂性为$O((n-1)!)\times O(1) = O((n-1)!)$​

---

### 装载问题

#### 题目

将$n$个集装箱装上两艘载重分别为$c_1$和$c_2$的轮船，$w_i$为集装箱$i$的重量，且$\sum\limits_{i=1}^n w_i \leq c_1 + c_2$，问是否存在一种合理的装载方案，将$n$个集装箱装上轮船？

---

#### 思路

如果装载问题有解，则存在一个使得第一条船的实际装载量与$c_1$的差最小的解。从而可以使用回溯法，确定一个装载方案，使得第一条船的实际装载量$W_1$最大，并比较 货物总重与剩余货物的差 与第二条穿载重的大小。

1.   定义解向量、每个分量的取值范围、约束条件。

     -   解向量：$<x_1,x_2,\cdots,x_n>$，其中$x_i$表示第$i$个货物是否放入第一条船。
     -   每个分量$x_i$的取值范围$x_i \in \{0,1\}$​
     -   约束条件：$\sum\limits_{i=1}^kw_ix_i \leq c_1$
     -   搜索空间为子集树

2.   判断是否满足多米诺性质

     令$P(x_1,x_2,\cdots,x_k)$为$\sum\limits_{i=1}^kw_ix_i > c_1$，从而
     $$
     \sum\limits_{i=1}^kw_ix_i > c_1 \rightarrow \sum\limits_{i=1}^{k+1}w_ix_i > c_1
     $$

3.   确定搜索策略：深度优先.

---

#### 算法描述

Loading(W,c1)

输入：集装箱重量$W = <w_1,w_2,\cdots,w_n>$，$c_1$是第一条船的载重

输出：使得第一条船装载量最大的装载方案$<x_1,x_2,\cdots,x_n>$，其中$x_i \in {0,1}$

1.   B <- c1; best <- c1; i<- 1
2.   while i <= n do
3.   ​    if 装入i后重量不超过c1
4.   ​    then B <- B - wi; x[i] <- 1 ; i <- i+1
5.   ​    else x[i] <- 0; i <- i+1
6.   if B < best then 记录解; best <- B; i <- i-1
7.   Backtrack(i)
8.   if i=1 then return 最优解
9.   else goto 3



   Backtrack(i)

1.   while i>1 and x[i] = 0 do
2.   ​    i <- i-1
3.   if x[i] = 1 then x[i]<-0; B <- B + wi ; i <- i + 1

---

#### 算法时间复杂度分析

叶结点有$2^n$个，结点总数$O(2^n)$个，每个结点要计算装载量以判断是否回溯，到达叶结点的计算时间为$O(1)$，所以算法的计算时间复杂度为$O(2^n)$

### 图的m着色问题

### 最大团问题

### 圆排列问题

### 连续邮资问题



