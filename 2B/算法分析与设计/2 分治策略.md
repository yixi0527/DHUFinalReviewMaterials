# 基本思想

将规模为n的原问题归约为**彼此独立**的、**规模较小**而**结构相同**的子问题。递归地求解每个子问题，然后把子问题的解进行综合，从而得到原问题的解。

# 设计步骤

-   分解
-   递归求解
-   组合

在分治算法中，常见的递推方程有以下两类：

-   $T(n) = \sum\limits_{i=1}^k a_iT(n-i) + f(n)$​

    -   子问题的规模比原问题呈现常数量级的减少
    -   汉诺塔问题
    -   迭代法、递归树、尝试

-   $T(n) = aT(\frac{n}{b}) + f(n)$

    -   均衡划分的情况下，a代表子问题的个数，b代表子问题规模减少的倍数。$d(n)$表示归约过程和综合解过程的总工作量。

    -   主定理、迭代法、递归树

    -   当$f(n)$为常数时：
        $$
        T(n) = \left\{
        \begin{align}
        &\Theta(n^{\log_ba}) & a\neq1\\
        &\Theta(\log n) & a=1\\
        \end{align}
        \right.
        $$
         当$f(n)$为$cn$，$c$为常数时
        $$
        T(n) = \left\{
        \begin{align}
        &\Theta(n)&a<b \\
        &\Theta(n\log n) & a=b\\
        &\Theta(n^{\log_ba}) & a>b\\
        \end{align}
        \right.
        $$

# 分治法的改进

-   利用子问题之间的依赖关系，减少子问题的个数
-   利用预处理过程，减少递归内部运算量

寻找子问题之间的依赖关系。如果一个子问题的解可以用其他子问题的解通过简单的运算得到，那么在用到这个子问题的解时，不必重新递归计算，而是通过组合其他子问题的解来得到。

# 典型的分治算法

-   二分检索 logn
-   二分归并排序 nlogn
-   芯片测试 n
-   大整数相乘 n^log3
-   Strassen矩阵乘法 n^log7
-   最邻近点对 nlogn
-   快速排序 nlogn
-   选第$k$小 n